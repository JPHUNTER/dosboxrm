Index: include/video.h
===================================================================
--- include/video.h	(revision 4253)
+++ include/video.h	(working copy)
@@ -37,28 +37,32 @@
 	Bit8u unused;
 };
 
-#define GFX_CAN_8		0x0001
-#define GFX_CAN_15		0x0002
-#define GFX_CAN_16		0x0004
-#define GFX_CAN_32		0x0008
+#define GFX_CAN_8    0x0001
+#define GFX_CAN_15   0x0002
+#define GFX_CAN_16   0x0004
+#define GFX_CAN_32   0x0008
 
-#define GFX_LOVE_8		0x0010
-#define GFX_LOVE_15		0x0020
-#define GFX_LOVE_16		0x0040
-#define GFX_LOVE_32		0x0080
+#define GFX_LOVE_8   0x0010
+#define GFX_LOVE_15  0x0020
+#define GFX_LOVE_16  0x0040
+#define GFX_LOVE_32  0x0080
 
-#define GFX_RGBONLY		0x0100
+#define GFX_RGBONLY  0x0100
+#define GFX_DBL_H    0x0200
+#define GFX_DBL_W    0x0400
 
-#define GFX_SCALING		0x1000
-#define GFX_HARDWARE	0x2000
+#define GFX_SCALING  0x1000
+#define GFX_HARDWARE 0x2000
 
 #define GFX_CAN_RANDOM	0x4000		//If the interface can also do random access surface
+#define GFX_UNITY_SCALE 0x8000      //Signifies that no scaling need be performed in render.cpp
+                                    //because it will be handled in sdlmain.cpp.
 
 void GFX_Events(void);
 void GFX_SetPalette(Bitu start,Bitu count,GFX_PalEntry * entries);
 Bitu GFX_GetBestMode(Bitu flags);
 Bitu GFX_GetRGB(Bit8u red,Bit8u green,Bit8u blue);
-Bitu GFX_SetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley,GFX_CallBack_t cb);
+Bitu GFX_SetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley,GFX_CallBack_t cb, double aspect);
 
 void GFX_ResetScreen(void);
 void GFX_Start(void);
Index: src/dosbox.cpp
===================================================================
--- src/dosbox.cpp	(revision 4253)
+++ src/dosbox.cpp	(working copy)
@@ -383,6 +383,7 @@
 
 
 void DOSBOX_Init(void) {
+	//setenv( "SDL_VIDEO_CENTERED", "1", 1 ); //won't work with MinGW
 	Section_prop * secprop;
 	Section_line * secline;
 	Prop_int* Pint;
@@ -447,11 +448,11 @@
 	Pint->SetMinMax(0,10);
 	Pint->Set_help("How many frames DOSBox skips before drawing one.");
 
-	Pbool = secprop->Add_bool("aspect",Property::Changeable::Always,false);
+	Pbool = secprop->Add_bool("aspect",Property::Changeable::Always,true);
 	Pbool->Set_help("Do aspect correction, if your output method doesn't support scaling this can slow things down!");
 
 	Pmulti = secprop->Add_multi("scaler",Property::Changeable::Always," ");
-	Pmulti->SetValue("normal2x");
+	Pmulti->SetValue("none");
 	Pmulti->Set_help("Scaler used to enlarge/enhance low resolution modes. If 'forced' is appended,\n"
 	                 "then the scaler will be used even if the result might not be desired.\n"
 					 "To fit a scaler in the resolution used at full screen may require a border or side bars,\n"
Index: src/gui/Makefile.am
===================================================================
--- src/gui/Makefile.am	(revision 4253)
+++ src/gui/Makefile.am	(working copy)
@@ -7,5 +7,6 @@
 	render_templates_sai.h render_templates_hq.h \
 	render_templates_hq2x.h render_templates_hq3x.h \
 	midi.cpp midi_win32.h midi_oss.h midi_coreaudio.h midi_alsa.h \
+	pixelscale.h pixelscale.cpp \
 	midi_coremidi.h sdl_gui.cpp dosbox_splash.h
 
Index: src/gui/pixelscale.cpp
===================================================================
--- src/gui/pixelscale.cpp	(revision 0)
+++ src/gui/pixelscale.cpp	(working copy)
@@ -0,0 +1,693 @@
+#include <stdio.h>
+#include <math.h>
+#include <string.h>
+#include <stdlib.h>
+#include "pixelscale.h"
+
+typedef unsigned char uchar;
+
+typedef struct line_info
+{	int size;
+	int left;
+	int weight_l;
+	int weight_r;
+	int main_start;
+	int main_end;
+	int main_width;
+} line_info;
+
+enum NEIGHBOR
+{	N_TOP, N_BOTTOM, N_LEFT, N_RIGHT  };
+
+typedef struct cell_info
+{	signed weights[4];
+} cell_info;
+
+typedef struct info
+{	ps_size      size_in;
+	ps_format    fmt_in;
+	ps_format    fmt_out;
+	uchar        comp_n;
+	char         perfect; /* boolean flag */
+	double       scale_x;
+	double       scale_y;
+	line_info*   rows_info;
+	line_info*   cols_info;
+	cell_info*   cells; 
+	uchar       *ipl,*ipr;
+	uchar*       bound_cols[4];
+	uchar*       rowbuf;
+	char         nb;
+	char         dw;
+	char         dh;
+} info;
+
+typedef struct junct_info
+{	uchar   low;
+	uchar   high;
+	double  diff_lo;
+	double  diff_hi;
+	double  middle;
+} junct_info;
+
+static junct_info get_junct_info( double scale, char nb )
+{	junct_info ji;
+	ji.low     = floor(scale);
+	ji.high    = ji.low + 1;
+	ji.diff_hi =  (double)ji.high - scale;
+	ji.diff_lo = -(double)ji.low  + scale;
+	if( nb )
+	{	ji.middle = 0.0;  }
+	else
+	{	ji.middle = 0.0;  }
+	return ji;
+}
+
+static void li_filldim( line_info *pli, int left )
+{	pli->left       = left;
+	pli->main_start = left;
+	pli->main_end   = left + pli->size - 1;
+
+	if( pli->weight_l < 256 )
+	{	pli->main_start += 1;  }
+	if( pli->weight_r < 256 )
+	{	pli->main_end   -= 1;  }
+
+	pli->main_width = pli->main_end - pli->main_start + 1;
+}
+
+static void li_setsize( junct_info ji, line_info* pli, double *diff )
+{	if( *diff > ji.middle )
+	{	*diff = *diff - ji.diff_hi;
+		pli->size = ji.high;
+	}
+	else
+	{	*diff = *diff + ji.diff_lo;
+		pli->size = ji.low;
+	}
+}
+
+static line_info *li_get( unsigned length, double scale, double softness )
+{	double diff = 0.0;
+	int i;
+	int edgeDiff;
+	char nb = (softness == 0.0);
+	double dweight;
+	int*   edgeWeight;
+	int left = 0;
+	int dummy;
+	junct_info ji = get_junct_info( scale, nb );
+	line_info* res = (line_info*)calloc( length, sizeof( line_info ) ); 
+	line_info* pli = res;
+	for( i = 0; i < length; i++ )
+	{	res[i].weight_l = 256; res[i].weight_r = 256;  }
+	for( i = 0; i < length; i++ )
+	{	diff = scale * i - left;
+		li_setsize( ji, pli, &diff );
+		if( !nb )
+		{	if( diff  > 0.0 )
+			{	dweight = 1.0 - diff;
+				if( i < length - 1 )
+				{	edgeWeight = &(pli + 1)->weight_l;  }
+				else
+				{	edgeWeight = &dummy;  }
+			}
+			else
+			{	dweight = 1.0 + diff;
+				edgeWeight = &pli->weight_r;
+			}
+			dweight     = pow( dweight, softness );
+			*edgeWeight = round( dweight * 256 );
+		}
+
+		li_filldim( pli, left );
+
+		left = left + pli->size;
+		pli = pli + 1;
+	}
+	return res;
+}
+
+static uchar* alloc_colors( info* si )
+{	return (uchar*)calloc( si->size_in.h * si->size_in.w, si->comp_n );  }
+
+static uchar* new_color( info* si )
+{	return (uchar*)malloc( si->comp_n );  } 
+
+static void init_cells( info* si )
+{	int y, x;
+	line_info ri, ci;
+	ps_size size_in = si->size_in;
+	si->cells    = (cell_info*)calloc( sizeof( cell_info ), size_in.w * size_in.h );
+	cell_info* c = si->cells;
+	for( y = 0; y < size_in.h; y++ )
+	{	ri = si->rows_info[y];
+		for( x = 0; x < size_in.w; x++ )
+		{	ci = si->cols_info[x];
+
+			c->weights[N_TOP]    = ri.weight_l;
+			c->weights[N_BOTTOM] = ri.weight_r;
+			c->weights[N_LEFT]   = ci.weight_l;
+			c->weights[N_RIGHT]  = ci.weight_r;
+
+			c = c + 1;
+		}
+	}
+}
+
+static double rounddl( double f )
+{	double f0 = floor(f);
+	double f1 = f0 + 1.0;
+	if( f/f0 > f1/f  )
+	{	return f1; }
+	else
+	{	return f0;  }
+}
+
+static void get_perfect_scale_asp
+( double ar_in, double a_in, double a_out, double ratio, int *scalex, int *scaley )
+{	const double ASPECT_IMPORTANCE = 1.14; // Heruistic parameter
+	int sx, sy, sx_best, sy_best;
+	int sx_max = floor(ratio);
+	int sy_max = floor( ratio * a_out / ar_in + 0.000000000000005 );
+	if( sy_max == 0 )
+	{	sy_max = 1;  } // HACK for small output sizes
+	double bestfit = -99.0;
+
+	double fit;
+	double err_aspect;
+	for( sx = sx_max; sx > 0; sx-- )
+	{	sy = rounddl( (double)sx * a_in );
+		if( sy == 0 )
+		{	sy = 1;  } // HACK for small output sizes
+		if( sy > sy_max )
+		{	sy = sy - 1;  }
+		err_aspect = (double)sy/(double)sx / a_in;
+		if( err_aspect < 1.0 )
+		{	err_aspect = 1.0 / err_aspect;  }
+		err_aspect = powf( err_aspect, ASPECT_IMPORTANCE );
+		double xr = (double)sx/sx_max;
+		double yr = (double)sy/sy_max;
+		double sz;
+		if( xr > yr )
+		{	sz = xr;  }
+		else
+		{	sz = yr;  }
+		fit = (double)(sz + 0.2) / err_aspect;
+		if( fit > bestfit )
+		{	bestfit = fit;
+			*scalex = sx;
+			*scaley = sy;
+		}
+	}
+}
+
+/* TODO: To prevent rounding errors I have switched from float to double,    */
+/*       but it is a brute rather than intelligent solution.  It will be     */
+/*       better to operate with pixel measurements directly instead of       */
+/*       converting them into normalized real ratios, as done currently.     */
+static void get_perfect_scale
+( ps_size size_in, float a_in, ps_size size_out, int* scalex, int* scaley )
+{	double a_x, a_y;
+	double ca_in, ca_out;
+	double cratio; 
+	double ar;
+	int *sw, *sh;
+	if( a_in > 1.0 )
+	{	a_y = a_in;     a_x = 1.0;  }
+	else
+	{	a_x = 1.0/a_in; a_y = 1.0;  }
+	if( size_out.w / (size_in.w * a_x) < size_out.h / (size_in.h * a_y) )
+	{	ca_in  = a_in;
+		ca_out = (double)size_out.h/size_out.w;
+		cratio = (double)size_out.w/size_in.w;
+		sw     = scalex; sh = scaley;
+		ar     = (double)size_in.h/size_in.w;
+	}
+	else
+	{	ca_in  = 1.0/a_in;
+		ca_out = (double)size_out.w/size_out.h;
+		cratio = (double)size_out.h/size_in.h;
+		sw     = scaley; sh = scalex;
+		ar     = (double)size_in.w/size_in.h;
+	}
+	get_perfect_scale_asp( ar, ca_in, ca_out, cratio, sw, sh );
+}
+
+static void free_if_not_null( void *ptr )
+{	if( ptr != NULL )
+	{	free( ptr );  }
+}
+
+static void init_bound_cols( info* si )
+{	uchar i;
+	for( i = 0; i < 4; i++ )
+	{	si->bound_cols[i] = new_color( si );  }
+}
+
+static void free_bound_cols( info* si )
+{	uchar i;
+	for( i = 0; i < 4; i++ )
+	{	free_if_not_null( si->bound_cols[i] );  }
+}
+
+static ps_info new_info
+(	ps_format fmt_in,
+	ps_size   size_in,
+	ps_format fmt_out,
+	ps_size   size_out,
+	uchar     comp_n,
+	double    softness,
+	char      dw,
+	char      dh
+)
+{	int i;
+	ps_info res = (ps_info)malloc(sizeof(info));
+	info* si = (info*)res;
+	si->dw        = dw;
+	si->dh        = dh;
+	si->comp_n    = comp_n;
+	si->fmt_in    = fmt_in;
+	si->size_in   = size_in;
+	si->fmt_out   = fmt_out;
+	si->scale_x   = ( double )size_out.w / size_in.w;
+	si->scale_y   = ( double )size_out.h / size_in.h;
+	si->perfect   = si->scale_x == (int)si->scale_x &&
+	                si->scale_y == (int)si->scale_y;
+	si->nb        = softness == 0.0 || si->perfect;
+	si->rows_info = li_get( size_in.h, si->scale_y, softness );
+	si->cols_info = li_get( size_in.w, si->scale_x, softness );
+	si->ipl       = new_color( si );
+	si->ipr       = new_color( si );
+	// TODO: In case of allocation errors, call ps_free and return NULL
+	// TODO: Because the exact pitch is not known at init time:
+	si->rowbuf    = (uchar*)malloc( size_out.w * fmt_out.step );
+	for( i = 0; i < size_out.w * fmt_out.step; i++ )
+	{	si->rowbuf[i] = 0;  }
+	init_cells( si );
+	init_bound_cols( si );
+	return res;
+}
+
+static void handle_dwh_new
+( char dw, char dh, ps_format *fmt_in, ps_size* size, double* par )
+{	if( dh )
+	{	size->h /= 2;
+		*par    *= 2;
+	}
+	if( dw )
+	{	size->w      /= 2;
+		*par         /= 2;
+		fmt_in->step *= 2;
+	}
+}
+
+static void handle_dwh_scale
+( char dw, char dh, ps_pixels *pix_in, ps_rect* rect )
+{	if( dh )
+	{	pix_in->pitch *= 2;
+		rect->h       /= 2;
+		rect->y       /= 2;
+	}
+	if( dw )
+	{	rect->w /= 2;
+		rect->x /= 2;
+	}
+}
+
+ps_info ps_new_soft
+(	ps_format     const fmt_in,
+	ps_size       const size_in,
+	ps_format     const fmt_out,
+	ps_size       const size_out,
+	char          const dw,
+	char          const dh,
+	unsigned char const comp_n,
+	double        const softness
+)
+{	double par_dummy;
+	ps_size size_in_calc = size_in;
+	ps_format fmt_in_calc = fmt_in;
+	handle_dwh_new( dw, dh, &fmt_in_calc, &size_in_calc, &par_dummy );
+	return new_info( fmt_in_calc, size_in_calc, fmt_out, size_out, comp_n, softness, dw, dh );
+}
+
+ps_info ps_new_nn
+(	ps_format     const fmt_in,
+	ps_size       const size_in,
+	ps_format     const fmt_out,
+	ps_size       const size_out,
+	char          const dw,
+	char          const dh,
+	unsigned char const comp_n
+)
+{	double par_dummy;
+	ps_size   size_in_calc = size_in;
+	ps_format fmt_in_calc  = fmt_in;
+	handle_dwh_new( dw, dh, &fmt_in_calc, &size_in_calc, &par_dummy );
+	return new_info( fmt_in_calc, size_in_calc, fmt_out, size_out, comp_n, 
+		0.0, dw, dh );
+}
+
+ps_info ps_new_perfect
+(	ps_format     const fmt_in,
+	ps_size       const size_in,
+	ps_format     const fmt_out,
+	ps_size       const size_out,
+	char          const dw,
+	char          const dh,
+	unsigned char const comp_n,
+	double        const aspect_in,
+	ps_size*      const size_res
+)
+{	int sx, sy;
+	double aspect = aspect_in;
+	ps_size   size_in_calc = size_in;
+	ps_format fmt_in_calc  = fmt_in;
+	handle_dwh_new( dw, dh, &fmt_in_calc, &size_in_calc, &aspect );
+	get_perfect_scale( size_in_calc, aspect, size_out, &sx, &sy );
+	size_res->w = sx * size_in_calc.w;
+	size_res->h = sy * size_in_calc.h;
+	return new_info( fmt_in_calc, size_in_calc, fmt_out, *size_res, comp_n,
+		0.0, dw, dh );
+}
+
+void ps_free ( ps_info const osi )
+{	info* si = (info*)osi;
+	free_if_not_null( si->ipl );
+	free_if_not_null( si->ipr );
+	free_if_not_null( si->cols_info );
+	free_if_not_null( si->rows_info );
+	free_if_not_null( si->cells );
+	free_if_not_null( si->rowbuf );
+	free_bound_cols( si );
+	free( si );
+}
+
+// TODO: Maybe precalculate the difference 256 - weight also?
+static inline uchar interpolate_comp( unsigned weight, uchar current, uchar that )
+{	return ( (int)current * weight + (int)that * ( 256 - weight ) ) >> 8;  }
+
+static inline void interpolate_pixel( unsigned weight, uchar* current, uchar* that, int count, uchar* res )
+{	int c;
+	for( c = 0; c < count; c++ )
+	{	*res = interpolate_comp( weight, *current, *that );
+		res++; current++; that++;
+	}
+}
+
+static uchar* get_nb_pix( ps_pixels image, uchar* pixel, int step, int nb )
+{	int offset;
+	switch (nb)
+	{	case N_TOP:    offset = -image.pitch; break;
+		case N_BOTTOM: offset =  image.pitch; break;
+		case N_LEFT:   offset = -step; break;
+		case N_RIGHT:  offset =  step; break;
+	}
+	return pixel + offset;
+}
+
+static inline void get_boundary_colors
+	( cell_info *cell, ps_pixels pix_in, uchar* pixel, info* si  )
+{	uchar i;
+	signed weight;
+	uchar* color;
+	/* TODO: unroll this loop: */
+	for( i = 0; i < 4; i++ )
+	{	weight = cell->weights[i];
+		if( weight < 256 )
+		{	color = get_nb_pix( pix_in, pixel, si->fmt_in.step, i);
+			interpolate_pixel
+				( weight, pixel, color, si->comp_n, si->bound_cols[i] );
+		}
+	}
+}
+
+static inline uchar* addr( uchar* start, int size, int x, int y, int pitch )
+{	return start + y * pitch + x * size;  }
+
+// TODO: restructure the internal types so as to make this easier:
+static inline uchar* addr_img( uchar step, ps_pixels pixels, int x, int y )
+{	return addr( pixels.pixels, step, x, y, pixels.pitch );  }
+
+static inline void put_and_shift
+	( ps_format fmt, uchar comp_n, uchar** row, uchar* pixel )
+{	memcpy( *row, pixel, comp_n );
+	*row = *row + fmt.step; 
+}
+
+static inline void fill_subrow
+( info* si, uchar** row, line_info *ci, uchar* left, uchar* right, uchar* current )
+{	uchar i;
+	ps_format fmt_out;
+	uchar comp_n;
+	fmt_out = si->fmt_out;
+	comp_n  = si->comp_n;
+	if( ci->weight_l < 256 )
+	{	put_and_shift( fmt_out, comp_n, row, left );  }
+	for( i = 0; i < ci->main_width; i++ )
+	{	put_and_shift( fmt_out, comp_n, row, current );  }
+	if( ci->weight_r < 256 )
+	{	put_and_shift( fmt_out, comp_n, row, right );  }
+}
+
+static inline uchar color_diff( uchar* a, uchar* b, uchar count )
+{	unsigned full = 0;
+	int comp_diff;
+	uchar i;
+	for( i = 0; i < count; i++ )
+	{	comp_diff = *a - *b;
+		if( comp_diff < 0 )
+		{	comp_diff = - comp_diff;  }
+		full = full + comp_diff;
+		a = a + 1;
+		b = b + 1;
+	}
+	return (uchar)(full / count);
+}
+
+static inline void interpolate_corner
+( uchar comp_n, uchar* current, uchar cur_diff, uchar add_diff, uchar* other, uchar* res )
+{	double dweight = (double)cur_diff / ( (double)add_diff + (double)cur_diff ) * 255;
+	uchar   weight = ( uchar )round( dweight );
+	interpolate_pixel( weight, current, other, comp_n, res );
+}
+
+static inline void fill_boundary
+(	uchar** row, info* si, line_info *ci, ps_pixels pix_in,
+	NEIGHBOR n, cell_info *cell, uchar* pixel )
+{	uchar cur_diff, add_diff;
+	uchar weight;
+	uchar    **bounds    = si->bound_cols;
+	uchar* color;
+	signed *weights;
+	uchar  step;
+
+	/* TODO: Store in each cell: four fields of each wieghts and four fields of
+	         each offset (for speed) */
+	step = si->fmt_in.step;
+	weights = cell->weights;
+	color = get_nb_pix( pix_in, pixel, step, n );
+	cur_diff = color_diff( color, pixel, si->comp_n );
+	if( weights[N_LEFT] < 256 )
+	{	color = get_nb_pix( pix_in, pixel, step, N_LEFT );
+		add_diff = color_diff( color, pixel, si->comp_n );
+		interpolate_corner( si->comp_n, bounds[n], cur_diff, add_diff, bounds[N_LEFT], si->ipl ); 
+	}
+	if( weights[N_RIGHT] < 256 )
+	{	color = get_nb_pix( pix_in, pixel, step, N_RIGHT );
+		add_diff = color_diff( color, pixel, si->comp_n );
+		interpolate_corner( si->comp_n, bounds[n], cur_diff, add_diff, bounds[N_RIGHT], si->ipr ); 
+	}
+	fill_subrow( si, row, ci, si->ipl, si->ipr, bounds[n] );
+}
+
+static void inc_rect( ps_rect* rect, ps_size size, char l, char r, char t, char b )
+{	if( ( rect->x + rect->w < size.w ) && r )
+	{	rect->w++;  }
+	if( rect->y + rect->h < size.h && b )
+	{	rect->h++;  }
+	if( rect->x > 0 && l )
+	{	rect->x--; rect->w++;  }
+	if( rect->y > 0 && t )
+	{	rect->y--; rect->h++;  }
+}
+
+static ps_rect get_color_rect( info* si, ps_rect rect, ps_size size )
+{	ps_rect colRect = rect;
+	inc_rect
+	(	&colRect, size, 
+		si->cols_info[rect.x].weight_l < 256,
+		si->cols_info[rect.x + rect.w - 1].weight_r < 256,
+		si->rows_info[rect.y].weight_l < 256,
+		si->rows_info[rect.y + rect.h - 1].weight_r < 256
+	);
+	return colRect;
+}
+
+static void pass_through
+(	info* si,
+	uchar* src,
+	line_info* ci,
+	uchar** mid_cur,
+	cell_info *cell
+)
+{	int mc;
+	int step;
+	uchar comp_n;
+	comp_n = si->comp_n;
+	step = si->fmt_out.step;
+	for( mc = 0; mc < ci->size; mc++ )
+	{	memcpy( *mid_cur, src, comp_n );
+		*mid_cur = *mid_cur + step;
+	}
+}
+
+static void set_area( info* si, ps_rect* area )
+{	int x,y;
+	x       = floor( si->scale_x *  area->x );
+	area->w = round( si->scale_x * (area->x + area->w )) - x;
+	area->x = x;
+	y       = floor( si->scale_y *  area->y );
+	area->h = round( si->scale_y * (area->y + area->h )) - y;
+	area->y = y;
+}
+
+typedef struct rowstart
+{	uchar*     out;
+	uchar*     in;
+	cell_info* cell;
+} rowstart;
+
+static void rs_init( info* si, ps_rect* area,
+	ps_pixels pix_in, ps_pixels pix_out, rowstart* rs )
+{	rs->cell = si->cells + area->y * si->size_in.w + area->x;
+	rs->in   = addr_img( si->fmt_in.step, pix_in, area->x, area->y );
+	rs->in   = rs->in + si->fmt_in.offs;
+	rs->out  = addr_img( si->fmt_out.step, pix_out,
+		si->cols_info[area->x].left, si->rows_info[area->y].left );
+	rs->out  = rs->out + si->fmt_out.offs;
+}
+
+static void rs_next( rowstart* rs, info* si, ps_pixels pix_in, ps_pixels pix_out, line_info ri )
+{	rs->out  = rs->out  + ri.size * pix_out.pitch;
+	rs->cell = rs->cell + si->size_in.w;
+	rs->in   = rs->in   + pix_in.pitch;
+}
+
+static void scale_init
+(	info* si, ps_pixels* pix_inP, ps_pixels pix_out,
+	ps_rect* area,
+	unsigned* width_bytesP, rowstart* rsP
+)
+{	ps_rect col_rect;
+	// WARN: for some reason the local buffer works faster even though
+	//       I have to allocate and initialize it at every call:
+	// *mid_rowP = (uchar*)malloc( pix_out.pitch );
+
+	handle_dwh_scale( si->dw, si->dh, pix_inP, area );
+
+	if( !si->nb )
+	{	inc_rect( area, si->size_in, 1, 1, 1, 1 );
+	}
+
+	*width_bytesP = si->fmt_out.step * 
+		(	si->cols_info[area->x + area->w - 1].left +
+			si->cols_info[area->x+area->w-1].size -
+		 	si->cols_info[area->x].left
+		) - si->fmt_out.offs;
+
+	rs_init( si, area, *pix_inP, pix_out, rsP );
+}
+
+static void loopx_nb
+(	info* si, ps_rect *area, uchar* src, rowstart* rs )
+{	int x_in;
+	line_info ci;
+	uchar* mid_cur;
+	cell_info* cell;
+
+	cell = rs->cell;
+	mid_cur = si->rowbuf;
+	for( x_in = area->x; x_in < area->x + area->w; x_in++ )
+	{	ci = si->cols_info[x_in];
+		pass_through( si, src, &ci, &mid_cur, cell );
+		cell++;
+		src = src + si->fmt_in.step;
+	}
+}
+
+static void loopx_np
+(	info* si, ps_rect *area, uchar* src, rowstart* rs,
+	line_info ri, ps_pixels pix_in, ps_pixels pix_out
+)
+{	int x_in;
+	line_info ci;
+	cell_info* cell;
+	uchar *top_cur, *bot_cur;
+
+	cell    = rs->cell;
+	top_cur = rs->out;
+	bot_cur = rs->out + (ri.size - 1) * pix_out.pitch;
+	uchar* mid_cur = si->rowbuf;
+
+	for( x_in = area->x; x_in < area->x + area->w; x_in++ )
+	{	ci = si->cols_info[x_in];
+		get_boundary_colors( cell, pix_in, src, si );
+		if( ri.weight_l  < 256 )
+		{	fill_boundary( &top_cur, si, &ci, pix_in, N_TOP,    cell, src );  }
+		if( ri.weight_r  < 256 )
+		{	fill_boundary( &bot_cur, si, &ci, pix_in, N_BOTTOM, cell, src );  }
+		if( ri.main_width == 0 )
+		{	goto next_pixel;  }
+		fill_subrow( si, &mid_cur, &ci,
+			si->bound_cols[N_LEFT ],
+			si->bound_cols[N_RIGHT],
+			src
+		);
+	next_pixel:
+		cell++;
+		src = src + si->fmt_in.step;
+	}
+}
+
+void ps_scale( ps_info const osi, ps_pixels pix_in, ps_pixels const pix_out, ps_rect* area )
+{	info* si = (info*)osi;
+	int       y_in;
+	uchar     mid_y;
+	line_info ri;
+	uchar*    mid_row;
+	uchar     *src;
+	char      nb;
+	unsigned  width_bytes;
+	uchar* mid_row_out;
+	rowstart rs;
+
+	nb     = si->nb;
+
+	scale_init( si, &pix_in, pix_out, area, &width_bytes, &rs );
+
+	for( y_in = area->y; y_in < area->y + area->h; y_in++ )
+	{	src  = rs.in;
+		ri   = si->rows_info[y_in];
+
+		/* Loop separated into two for optimization: */
+		if( nb )
+		{	loopx_nb( si, area, src, &rs );  }
+		else
+		{	loopx_np( si, area, src, &rs, ri, pix_in, pix_out );  }
+
+		/* copy the middle row, if present, to output: */
+		if( ri.main_width > 0 ) 
+		{	mid_row_out = rs.out +
+			( ri.main_start - ri.left ) * pix_out.pitch;
+			for( mid_y = 0; mid_y < ri.main_width; mid_y++ )
+			{	memcpy(	mid_row_out, si->rowbuf, width_bytes );
+				mid_row_out = mid_row_out + pix_out.pitch;
+			}
+		}
+		rs_next( &rs, si, pix_in, pix_out, ri );
+	}
+	//free( mid_row );
+	set_area( si, area );
+}
Index: src/gui/pixelscale.h
===================================================================
--- src/gui/pixelscale.h	(revision 0)
+++ src/gui/pixelscale.h	(working copy)
@@ -0,0 +1,67 @@
+/* This unit currently supports only graphical modes
+   with one byte per component, therefore:
+	TODO: Consider using color masks to support arbitrary
+	      color modes.
+*/
+
+#ifndef PIXEL_SCALE 
+#define PIXEL_SCALE
+
+typedef struct ps_rect
+{	int x, y, w, h;  } ps_rect;
+
+typedef struct ps_format
+{	unsigned char offs;
+	unsigned char step;
+} ps_format;
+
+typedef struct ps_size
+{	unsigned w;
+	unsigned h;
+} ps_size;
+
+typedef struct ps_pixels
+{	unsigned char* pixels;
+	unsigned       pitch;
+} ps_pixels;
+
+        struct ps_info_internal;
+typedef struct ps_info_internal* ps_info;
+
+ps_info ps_new_soft
+(	ps_format     const fmt_in,
+	ps_size       const size_in,
+	ps_format     const fmt_out,
+	ps_size       const size_out,
+	char          const dw,
+	char          const dh,
+	unsigned char const comp_n,
+	double        const softness
+);
+
+ps_info ps_new_nn
+(	ps_format     const fmt_in,
+	ps_size       const size_in,
+	ps_format     const fmt_out,
+	ps_size       const size_out,
+	char          const dw,
+	char          const dh,
+	unsigned char const comp_n
+);
+
+ps_info ps_new_perfect
+(	ps_format     const fmt_in,
+	ps_size       const size_in,
+	ps_format     const fmt_out,
+	ps_size       const size_out,
+	char          const dw,
+	char          const dh,
+	unsigned char const comp_n,
+	double        const aspect_in,
+	ps_size*      const size_res
+);
+
+void ps_scale( ps_info const si, ps_pixels const pix_in, ps_pixels const pix_out, ps_rect* area );
+void ps_free ( ps_info const si );
+#endif
+
Index: src/gui/render.cpp
===================================================================
--- src/gui/render.cpp	(revision 4253)
+++ src/gui/render.cpp	(working copy)
@@ -398,7 +398,26 @@
 			gfx_flags = (gfx_flags & ~GFX_CAN_8) | GFX_RGBONLY;
 			break;
 	}
-	gfx_flags=GFX_GetBestMode(gfx_flags);
+
+	gfx_flags=GFX_GetBestMode(gfx_flags); 
+	if
+	(	(gfx_flags & GFX_UNITY_SCALE) &&
+		complexBlock == 0 &&
+		strstr( simpleBlock->name, "Normal" ) == simpleBlock->name
+	)  
+	// Ant_222 simply setting GFX_SCALING doesn't work
+	// Ant_222: bad idea to set UNITY_SCALE here, because later, in SetSize(),
+	//          we may have to revert to the simple surface mode, but it will be late.
+	{	gfx_scalew = 1.0; gfx_scaleh = 1.0;
+		// Ant_222: all this is required simply to undo the dblw or dblh upscaling above
+		//complexBlock = 0;  // HACK: Ant_222: copy-pasted from under the forcenormal label
+		simpleBlock = &ScaleNormal1x;
+		xscale = 1;
+		yscale = 1;
+	}
+	// TODO: find out how to use dblw and dblh
+	//if( dblw ) gfx_flags |= GFX_DBL_W;
+	//if( dblh ) gfx_flags |= GFX_DBL_H;
 	if (!gfx_flags) {
 		if (!complexBlock && simpleBlock == &ScaleNormal1x) 
 			E_Exit("Failed to create a rendering output");
@@ -419,7 +438,17 @@
 		}
 	}
 /* Setup the scaler variables */
-	gfx_flags=GFX_SetSize(width,height,gfx_flags,gfx_scalew,gfx_scaleh,&RENDER_CallBack);
+
+	double par; // the pixel aspect ratio of the source pixel array
+	if( render.aspect ) par = (double)width/height*3/4;//render.src.ratio;
+	else // DOSBox's own dblw and dblh flags are not always correct,
+	     // so let us gesstimate them ourselves:
+	{	double aspect = (double)width/height;
+		     if( aspect < 1.0 ) par = 0.5;
+		else if( aspect > 2.0 ) par = 2.0;
+		else                    par = 1.0;
+	}
+	gfx_flags=GFX_SetSize(width,height,gfx_flags,gfx_scalew,gfx_scaleh,&RENDER_CallBack, par );
 	if (gfx_flags & GFX_CAN_8)
 		render.scale.outMode = scalerMode8;
 	else if (gfx_flags & GFX_CAN_15)
@@ -514,6 +543,7 @@
 }
 
 void RENDER_SetSize(Bitu width,Bitu height,Bitu bpp,float fps,double ratio,bool dblw,bool dblh) {
+	//LOG_MSG("RENDER_SetSize: %ix%i", width, height);
 	RENDER_Halt( );
 	if (!width || !height || width > SCALER_MAXWIDTH || height > SCALER_MAXHEIGHT) { 
 		return;	
Index: src/gui/sdlmain.cpp
===================================================================
--- src/gui/sdlmain.cpp	(revision 4253)
+++ src/gui/sdlmain.cpp	(working copy)
@@ -49,6 +49,8 @@
 #include "cpu.h"
 #include "cross.h"
 #include "control.h"
+#include "math.h"
+#include "pixelscale.h"
 
 #define MAPPERFILE "mapper-" VERSION ".map"
 //#define DISABLE_JOYSTICK
@@ -127,13 +129,48 @@
 #include <os2.h>
 #endif
 
-enum SCREEN_TYPES	{
-	SCREEN_SURFACE,
+/* ----------------------------- output-type-specific declarations --------------------- */
+/* TODO store them in a separate .h-file or together with output-type specific functions */
+enum SCREEN_TYPES
+{	SCREEN_SURFACE,
 	SCREEN_SURFACE_DDRAW,
 	SCREEN_OVERLAY,
 	SCREEN_OPENGL
 };
 
+typedef Bitu (*FGetBestMode)( Bitu *flags );
+typedef char (*FSetSize    )(Bitu width,Bitu height,Bitu flags,double scalex,double scaley, Bitu *retflags);typedef char (*FStartUpdate)( Bit8u **pixels, Bitu *pitch );
+typedef void (*FEndUpdate  )( const Bit16u *changedLines );
+typedef Bitu (*FGetRgb     )( Bit8u red, Bit8u green, Bit8u blue );
+typedef struct
+{	FGetBestMode GetBestMode;
+	FSetSize     SetSize;
+	FStartUpdate StartUpdate;
+	FEndUpdate   EndUpdate;
+	FGetRgb      GetRgb;} ScreenTypeInfo;
+
+typedef ScreenTypeInfo *PScreenTypeInfo;
+
+PScreenTypeInfo GetScreenTypeInfo( Bitu gotbpp, SCREEN_TYPES type );
+
+enum SURFACE_MODE
+{	SM_SIMPLE,
+	SM_PERFECT,
+	SM_SOFT,
+	SM_NEIGHBOR
+};
+
+typedef void (*F_SO_Init)(Bit16u w_in, Bit16u h_in, Bit16u *w_out, Bit16u *h_out, int* bpp );
+typedef void (*F_SO_EndUpdate)();
+
+typedef struct SurfaceModeInfo
+{
+	F_SO_Init      Init;
+	FStartUpdate   StartUpdate;
+	F_SO_EndUpdate EndUpdate;
+} SurfaceModeInfo;
+/* ------------------ end of output-type-specific declarations ------------------------ */
+
 enum PRIORITY_LEVELS {
 	PRIORITY_LEVEL_PAUSE,
 	PRIORITY_LEVEL_LOWEST,
@@ -143,6 +180,7 @@
 	PRIORITY_LEVEL_HIGHEST
 };
 
+enum GlKind { GlkBilinear, GlkNearest, GlkPerfect };
 
 struct SDL_Block {
 	bool inited;
@@ -151,6 +189,7 @@
 	struct {
 		Bit32u width;
 		Bit32u height;
+		double aspect;
 		Bit32u bpp;
 		Bitu flags;
 		double scalex,scaley;
@@ -167,11 +206,12 @@
 		} window;
 		Bit8u bpp;
 		bool fullscreen;
+		bool fullborderless;
 		bool lazy_fullscreen;
 		bool lazy_fullscreen_req;
 		bool doublebuf;
-		SCREEN_TYPES type;
 		SCREEN_TYPES want_type;
+		ScreenTypeInfo screen;
 	} desktop;
 #if C_OPENGL
 	struct {
@@ -181,10 +221,11 @@
 		GLuint texture;
 		GLuint displaylist;
 		GLint max_texsize;
-		bool bilinear;
+		enum GlKind kind;
 		bool packed_pixel;
 		bool paletted_texture;
 		bool pixel_buffer_object;
+		bool vsync;
 	} opengl;
 #endif
 	struct {
@@ -209,7 +250,15 @@
 		int xsensitivity;
 		int ysensitivity;
 	} mouse;
+	SURFACE_MODE SurfaceMode;
+	SurfaceModeInfo SurfaceInfo;
+	double    ps_sharpness;
+	ps_pixels ps_buffer;
+	ps_info   pixel_scaling;
+	char      dbl_h, dbl_w;
+	double    ps_scale_x, ps_scale_y;
 	SDL_Rect updateRects[1024];
+	unsigned rectCount;
 	Bitu num_joysticks;
 #if defined (WIN32)
 	bool using_windib;
@@ -223,31 +272,44 @@
 
 static SDL_Block sdl;
 
+static void Cls( SDL_Surface *s )
+{	bool opengl = false;	
+	unsigned char r = 0, g = 0, b = 0; // TODO: make it configurable?
+#if C_OPENGL
+	if ( ( s->flags & SDL_OPENGL) != 0 )
+	{	opengl = true;
+		glClearColor ((float)r/255, (float)g/255, (float)b/255, 1.0);
+		glClear(GL_COLOR_BUFFER_BIT);
+		SDL_GL_SwapBuffers();
+		glClearColor ((float)r/255, (float)g/255, (float)b/255, 1.0);
+		glClear(GL_COLOR_BUFFER_BIT);
+	}
+#endif //C_OPENGL
+	if( !opengl )
+	{	SDL_FillRect(s,NULL,SDL_MapRGB(s->format,r,g,b));
+		SDL_Flip(s);
+		SDL_FillRect(s,NULL,SDL_MapRGB(s->format,r,g,b));
+	}
+}
+
 #define SETMODE_SAVES 1  //Don't set Video Mode if nothing changes.
 #define SETMODE_SAVES_CLEAR 1 //Clear the screen, when the Video Mode is reused
 SDL_Surface* SDL_SetVideoMode_Wrap(int width,int height,int bpp,Bit32u flags){
 #if SETMODE_SAVES
+	SDL_Surface* s;
 	static int i_height = 0;
 	static int i_width = 0;
 	static int i_bpp = 0;
 	static Bit32u i_flags = 0;
+	bool opengl = false;
 	if (sdl.surface != NULL && height == i_height && width == i_width && bpp == i_bpp && flags == i_flags) {
-		// I don't see a difference, so disabled for now, as the code isn't finished either
+/*		// I don't see a difference, so disabled for now, as the code isn't finished either
 #if SETMODE_SAVES_CLEAR
-		//TODO clear it.
-#if C_OPENGL
-		if ((flags & SDL_OPENGL)==0)
-			SDL_FillRect(sdl.surface,NULL,SDL_MapRGB(sdl.surface->format,0,0,0));
-		else {
-			glClearColor (0.0, 0.0, 0.0, 1.0);
-			glClear(GL_COLOR_BUFFER_BIT);
-			SDL_GL_SwapBuffers();
-		}
-#else //C_OPENGL
-		SDL_FillRect(sdl.surface,NULL,SDL_MapRGB(sdl.surface->format,0,0,0));
-#endif //C_OPENGL
+		Cls( sdl.surface, 0, 0, 0 );
 #endif //SETMODE_SAVES_CLEAR
-		return sdl.surface;
+		return sdl.surface;*/
+		// Clear an existing surface, because it matter for borderless fullscreen window:
+		s = sdl.surface; goto Done;
 	}
 
 
@@ -260,7 +322,8 @@
 	//Bug: we end up with a locked mouse cursor, but at least that beats crashing. (output=opengl,aspect=true,fullscreen=true)
 	if((i_flags&SDL_OPENGL) && !(flags&SDL_OPENGL) && (i_flags&SDL_FULLSCREEN) && !(flags&SDL_FULLSCREEN)){
 		GFX_SwitchFullScreen();
-		return SDL_SetVideoMode_Wrap(width,height,bpp,flags);
+		s = SDL_SetVideoMode_Wrap(width,height,bpp,flags);
+		goto Done;
 	}
 
 	//PXX
@@ -269,7 +332,7 @@
 	}
 #endif //WIN32
 #endif //SETMODE_SAVES
-	SDL_Surface* s = SDL_SetVideoMode(width,height,bpp,flags);
+	s = SDL_SetVideoMode(width,height,bpp,flags);
 #if SETMODE_SAVES
 	if (s == NULL) return s; //Only store when successful
 	i_height = height;
@@ -277,6 +340,7 @@
 	i_bpp = bpp;
 	i_flags = flags;
 #endif
+	Done: Cls( s );
 	return s;
 }
 
@@ -368,71 +432,879 @@
 }
 #endif
 
-/* Reset the screen with current values in the sdl structure */
-Bitu GFX_GetBestMode(Bitu flags) {
-	Bitu testbpp,gotbpp;
-	switch (sdl.desktop.want_type) {
-	case SCREEN_SURFACE:
-check_surface:
-		flags &= ~GFX_LOVE_8;		//Disable love for 8bpp modes
-		/* Check if we can satisfy the depth it loves */
-		if (flags & GFX_LOVE_8) testbpp=8;
-		else if (flags & GFX_LOVE_15) testbpp=15;
-		else if (flags & GFX_LOVE_16) testbpp=16;
-		else if (flags & GFX_LOVE_32) testbpp=32;
-		else testbpp=0;
-#if C_DDRAW
-check_gotbpp:
-#endif
-		if (sdl.desktop.fullscreen) gotbpp=SDL_VideoModeOK(640,480,testbpp,SDL_FULLSCREEN|SDL_HWSURFACE|SDL_HWPALETTE);
-		else gotbpp=sdl.desktop.bpp;
-		/* If we can't get our favorite mode check for another working one */
-		switch (gotbpp) {
-		case 8:
-			if (flags & GFX_CAN_8) flags&=~(GFX_CAN_15|GFX_CAN_16|GFX_CAN_32);
+static int int_log2 (int val) {
+    int log = 0;
+    while ((val >>= 1) != 0)
+	log++;
+    return log;
+}
+
+static SDL_Surface * GFX_SetupSurfaceScaled(Bitu flags, Bit32u sdl_flags, Bit32u bpp); // Forward decl.
+
+void CheckGotBpp( Bitu *flags, Bitu testbpp )
+{	Bitu gotbpp;
+	if (sdl.desktop.fullscreen)
+	{	gotbpp=SDL_VideoModeOK(640,480,testbpp,SDL_FULLSCREEN|SDL_HWSURFACE|SDL_HWPALETTE); }
+	else
+	{	gotbpp=sdl.desktop.bpp;  }
+	/* If we can't get our favorite mode check for another working one */
+	switch (gotbpp)
+	{	case 8:
+			if (*flags & GFX_CAN_8) *flags&=~(GFX_CAN_15|GFX_CAN_16|GFX_CAN_32);
 			break;
 		case 15:
-			if (flags & GFX_CAN_15) flags&=~(GFX_CAN_8|GFX_CAN_16|GFX_CAN_32);
+			if (*flags & GFX_CAN_15) *flags&=~(GFX_CAN_8|GFX_CAN_16|GFX_CAN_32);
 			break;
 		case 16:
-			if (flags & GFX_CAN_16) flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_32);
+			if (*flags & GFX_CAN_16) *flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_32);
 			break;
 		case 24:
 		case 32:
-			if (flags & GFX_CAN_32) flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
+			if (*flags & GFX_CAN_32) *flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
 			break;
+	}
+	*flags |= GFX_CAN_RANDOM;
+}
+
+Bitu CheckSurface( Bitu *flags )
+{	Bitu testbpp;
+	*flags &= ~GFX_LOVE_8;		//Disable love for 8bpp modes
+	/* Check if we can satisfy the depth it loves */
+	if (*flags & GFX_LOVE_8) testbpp=8;
+	else if (*flags & GFX_LOVE_15) testbpp=15;
+	else if (*flags & GFX_LOVE_16) testbpp=16;
+	else if (*flags & GFX_LOVE_32) testbpp=32;
+	else testbpp=0;
+	return testbpp;
+}
+
+void GetChangedLines( const Bit16u *changedLines )
+{	sdl.rectCount = 0; // if need be, declare it as a local variable and fill the parameter at the end.
+	if ( !changedLines )
+	{	return;  }
+
+	Bitu y = 0, index = 0;
+	while (y < sdl.draw.height)
+	{	if ( index & 1 )
+		{	SDL_Rect *rect = &sdl.updateRects[ sdl.rectCount++ ];
+			rect->x = 0;
+			rect->y = y;
+			rect->w = (Bit16u)sdl.draw.width;
+			rect->h = changedLines[index];
+#if 0
+			if (rect->h + rect->y > sdl.surface->h) {
+				LOG_MSG("WTF %d +  %d  >%d",rect->h,rect->y,sdl.surface->h);
+			}
+#endif
 		}
-		flags |= GFX_CAN_RANDOM;
+		y += changedLines[index];
+		index++;
+	}
+}
+
+static void GetAvailableArea( Bit16u *width, Bit16u *height, bool *fixed )
+{	*fixed = false;
+	if( sdl.desktop.fullscreen )
+	{	if( sdl.desktop.full.fixed )
+		{	*width  = sdl.desktop.full.width;
+			*height = sdl.desktop.full.height;
+			*fixed  = true;
+		}
+	}
+	else
+	{	if( sdl.desktop.window.width > 0 )
+		{	*width  = sdl.desktop.window.width;
+			*height = sdl.desktop.window.height;
+			*fixed  = true;
+		}
+	}
+}
+
+// ATT: aspect is the final aspect ratio of the image including its pixel dimensions and PAR
+static void GetActualArea( Bit16u av_w, Bit16u av_h, Bit16u *w, Bit16u *h, double aspect )
+{	double as_x, as_y;
+	if( aspect > 1.0 )
+	{	as_y = aspect  ; as_x = 1.0;  }
+	else
+	{	as_x = 1.0/aspect; as_y = 1.0;  }
+	if( av_h / as_y < av_w / as_x )
+	{	*h = av_h; *w = round( (double)av_h / aspect );  }
+	else
+	{	*w = av_w; *h = round( (double)av_w * aspect );  }
+}
+
+static Bit32u genflags( Bitu flags )
+{	Bit32u res;
+	res = 0;
+	if( sdl.desktop.fullscreen )
+	{	if( sdl.desktop.fullborderless )
+		{	res |= SDL_NOFRAME;
+			SDL_putenv("SDL_VIDEO_WINDOW_POS=center");
+		}
+		else
+		{	res |= SDL_FULLSCREEN;
+			if( sdl.desktop.doublebuf ) res |= SDL_DOUBLEBUF;
+		}
+	}
+	if( flags & GFX_CAN_RANDOM ) res |= SDL_SWSURFACE;
+	else                         res |= SDL_HWSURFACE;
+	return res;
+}
+
+/* ----------------- Operations depending on SCREEN_TYPES ----------------- */
+/* ----------------- Possibly move them to a separate unit ---------------- */
+
+ps_format rgb_32_fmt_in    = { 0, 4 };
+ps_format rgb_32_fmt_out   = { 0, 4 };
+
+void ssSmInit(Bit16u w_in, Bit16u h_in, Bit16u *w_out, Bit16u *h_out, int* bpp )
+{	*w_out = w_in;
+	*h_out = h_in;
+}
+
+ps_pixels ps_create_buffer( ps_size size )
+{	ps_pixels buf;
+	buf.pixels = (unsigned char*)calloc( 4, size.w * size.h );
+	buf.pitch  = size.w * 4;
+	return buf;
+}
+
+/* We must know the pixel layout before calling ps_new_*()                  */
+/* As a temporary solution, I (Ant_222) am reading it from the current mode */
+/* TODO: Rewrite the scaler so as to separate the calculation of the output */
+/*       dimensions from the initialization of the scaling structure. then  */
+/*       analyse the layout of the actual surface.                          */ 
+static void PsInitFormats( void )
+{	unsigned char offs;
+	const SDL_VideoInfo * i;
+	i = SDL_GetVideoInfo();
+	if( i->vfmt->Rshift > 0 && i->vfmt->Bshift > 0 )
+	{	offs = 1;  }
+	else
+	{	offs = 0;  }
+	rgb_32_fmt_in .offs = offs;
+	rgb_32_fmt_out.offs = offs;
+}
+
+/* TODO: these ~Init() functons are too repetitive, therefore generalize them */
+/*       via some common interface, e.g.: GetOutputSize, InitScaling:         */
+void ssPpInit(Bit16u w_in, Bit16u h_in, Bit16u *w_out, Bit16u *h_out, int* bpp )
+{	*bpp = 32;
+	ps_size size_in, size_out, size_res;
+	PsInitFormats();
+	size_in .w =  w_in ; size_in .h =  h_in;
+	size_out.w = *w_out; size_out.h = *h_out;
+	sdl.pixel_scaling = ps_new_perfect
+	(	rgb_32_fmt_in,   size_in,
+		rgb_32_fmt_out,  size_out,
+		sdl.dbl_w,       sdl.dbl_h, 3,
+		sdl.draw.aspect, &size_res
+	);
+	*h_out = size_res.h;
+	*w_out = size_res.w;
+	sdl.ps_buffer = ps_create_buffer( size_in );
+}
+
+void ssNpInit(Bit16u w_in, Bit16u h_in, Bit16u *w_out, Bit16u *h_out, int* bpp )
+{	*bpp = 32;
+	ps_size size_in, size_out;
+	PsInitFormats();
+	GetActualArea( *w_out, *h_out, w_out, h_out, sdl.draw.aspect * sdl.draw.height / sdl.draw.width );
+	size_in .w =  w_in ; size_in .h =  h_in;
+	size_out.w = *w_out; size_out.h = *h_out;
+	sdl.ps_buffer = ps_create_buffer( size_in );
+	sdl.pixel_scaling = ps_new_soft
+	(	rgb_32_fmt_in,  size_in,
+		rgb_32_fmt_out, size_out,
+		sdl.dbl_w,      sdl.dbl_h, 3,
+		(double)1.0-sdl.ps_sharpness
+	);
+}
+
+void ssNbInit(Bit16u w_in, Bit16u h_in, Bit16u *w_out, Bit16u *h_out, int* bpp )
+{	*bpp = 32;
+	ps_size size_in, size_out;
+	PsInitFormats();
+	GetActualArea( *w_out, *h_out, w_out, h_out, sdl.draw.aspect * sdl.draw.height / sdl.draw.width );
+	size_in .w =  w_in ; size_in .h =  h_in;
+	size_out.w = *w_out; size_out.h = *h_out;
+	sdl.ps_buffer = ps_create_buffer( size_in );
+	sdl.pixel_scaling = ps_new_nn
+	(	rgb_32_fmt_in,  size_in,
+		rgb_32_fmt_out, size_out,
+		sdl.dbl_w, sdl.dbl_h, 3
+	);
+}
+
+char ssGetOutPixels( Bit8u **pixels, Bitu *pitch )
+{	if( sdl.blit.surface != NULL )
+	{	if (SDL_MUSTLOCK(sdl.blit.surface) && SDL_LockSurface(sdl.blit.surface))
+			return 0;
+		*pixels=(Bit8u *)sdl.blit.surface->pixels;
+		*pitch=sdl.blit.surface->pitch;
+	}
+	else
+	{	if (SDL_MUSTLOCK(sdl.surface) && SDL_LockSurface(sdl.surface))
+			return 0;
+		*pixels=(Bit8u *)sdl.surface->pixels;
+		*pixels+=sdl.clip.y*sdl.surface->pitch;
+		*pixels+=sdl.clip.x*sdl.surface->format->BytesPerPixel;
+
+		*pitch=sdl.surface->pitch;
+	}
+	return 1;
+}
+
+char ssSmStartUpdate( Bit8u **pixels, Bitu *pitch )
+{	ssGetOutPixels( pixels, pitch );
+	return 1;
+}
+
+char ssPsStartUpdate( Bit8u **pixels, Bitu *pitch )
+{	*pixels = sdl.ps_buffer.pixels;
+	*pitch  = sdl.ps_buffer.pitch;
+	return 1;
+}
+
+void ssImageToScreen()
+{	if( sdl.blit.surface )
+	{	if( SDL_MUSTLOCK( sdl.blit.surface ) )
+			SDL_UnlockSurface(sdl.blit.surface);
+		SDL_BlitSurface( sdl.blit.surface, 0, sdl.surface, &sdl.clip );
+		SDL_Flip( sdl.surface );
+	}
+	else
+	{	if( SDL_MUSTLOCK( sdl.surface ) ) SDL_UnlockSurface(sdl.surface);
+		for( int i = 0; i < sdl.rectCount; i++ )
+		{	sdl.updateRects[i].x += sdl.clip.x;
+			sdl.updateRects[i].y += sdl.clip.y;
+		}
+		SDL_UpdateRects( sdl.surface, sdl.rectCount, sdl.updateRects );
+	}
+}
+
+void ssSmEndUpdate()
+{  }
+
+static void rect_sdl_to_ps( SDL_Rect const rect_sdl, ps_rect* rect_ps )
+{	rect_ps->x = rect_sdl.x;
+	rect_ps->y = rect_sdl.y;
+	rect_ps->w = rect_sdl.w;
+	rect_ps->h = rect_sdl.h;
+}
+
+static void rect_ps_to_sdl( ps_rect const rect_ps, SDL_Rect* rect_sdl )
+{	rect_sdl->x = rect_ps.x;
+	rect_sdl->y = rect_ps.y;
+	rect_sdl->h = rect_ps.h;
+	rect_sdl->w = rect_ps.w; 
+}
+
+void ssPsEndUpdate()
+{	int i;
+	Bitu pitch_bitu; // for type compatibility
+	ps_pixels pix_out;
+	ps_rect rect;
+	SDL_PixelFormat* format;
+
+	ssGetOutPixels( &pix_out.pixels, &pitch_bitu );
+	pix_out.pitch = pitch_bitu;
+	for( int i = 0; i < sdl.rectCount; i++ )
+	{	rect_sdl_to_ps( sdl.updateRects[i], &rect ); 
+		ps_scale( sdl.pixel_scaling, sdl.ps_buffer, pix_out, &rect );
+		rect_ps_to_sdl( rect, &sdl.updateRects[i] );
+	}
+}
+
+SurfaceModeInfo ssModes[4] =
+{	{ ssSmInit, ssSmStartUpdate, ssSmEndUpdate },
+	{ ssPpInit, ssPsStartUpdate, ssPsEndUpdate },
+	{ ssNpInit, ssPsStartUpdate, ssPsEndUpdate },
+	{ ssNbInit, ssPsStartUpdate, ssPsEndUpdate }
+};
+
+void ssSetSurfaceMode( SURFACE_MODE mode )
+{	sdl.SurfaceInfo = ssModes[ mode ];  }
+
+// TODO: Unity scale should be set later, when we are cetain that the resolution
+//       not the windowed-original
+Bitu ssBestMode( Bitu *flags )
+{	Bitu cs_res = CheckSurface( flags );
+	if( sdl.SurfaceMode != SM_SIMPLE )
+	{	*flags |= GFX_UNITY_SCALE;  }
+	return cs_res;
+}
+
+char ssSetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley, Bitu *retFlags)
+{	bool fixed;
+	Bit16u av_h, av_w, out_w, out_h;
+	int bpp;
+	SURFACE_MODE sm;
+	
+	if( sdl.pixel_scaling != NULL )
+	{	ps_free( sdl.pixel_scaling );
+		sdl.pixel_scaling = NULL;
+		free( sdl.ps_buffer.pixels );
+	}
+	av_w = width; av_h = height;
+	GetAvailableArea( &av_w, &av_h, &fixed );
+	if( !fixed && !sdl.desktop.fullscreen )
+	{	if( sdl.draw.aspect > 1.0 )
+		{	av_h *= sdl.draw.aspect;  }
+		if( sdl.draw.aspect < 1.0 )
+		{	av_w /= sdl.draw.aspect;  }
+	}
+	LOG_MSG("Available area: %ix%i", av_w, av_h);
+	ssSetSurfaceMode( sdl.SurfaceMode );
+
+	bpp = 0;
+	if (flags & GFX_CAN_8)  bpp= 8;
+	if (flags & GFX_CAN_15) bpp=15;
+	if (flags & GFX_CAN_16) bpp=16;
+	if (flags & GFX_CAN_32) bpp=32;
+
+	out_w = av_w; out_h = av_h;
+	sdl.SurfaceInfo.Init( width, height, &out_w, &out_h, &bpp );
+
+	sdl.ps_scale_x = ( double )out_w / width;
+	sdl.ps_scale_y = ( double )out_h / height;
+	char s[80];
+	LOG_MSG
+	(	"Scaling: %ix%i (%4.2f) --[%3.1f x %3.1f]--> %4ix%-4i (%4.2f)",
+		width, height, sdl.draw.aspect,
+		sdl.ps_scale_x, sdl.ps_scale_y,
+		out_w, out_h, sdl.ps_scale_y / sdl.ps_scale_x
+	);
+
+	Bit32u sfcflags = genflags( flags );
+	sdl.clip.w=out_w;
+	sdl.clip.h=out_h;
+	if (sdl.desktop.fullscreen) {
+		sfcflags |= SDL_HWPALETTE;
+		if (sdl.desktop.full.fixed) {
+			sdl.clip.x=(Sint16)((sdl.desktop.full.width -out_w)/2);
+			sdl.clip.y=(Sint16)((sdl.desktop.full.height-out_h)/2);
+			sdl.surface=SDL_SetVideoMode_Wrap(sdl.desktop.full.width,
+				sdl.desktop.full.height,bpp,sfcflags);
+
+			if (sdl.surface == NULL) E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",sdl.desktop.full.width,sdl.desktop.full.height,bpp,SDL_GetError());
+		} else {
+			sdl.clip.x=0;sdl.clip.y=0;
+			sdl.surface=SDL_SetVideoMode_Wrap(out_w,out_h,bpp,sfcflags);
+
+			if (sdl.surface == NULL)
+				E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",(int)width,(int)height,bpp,SDL_GetError());
+		}
+	} else {
+		sdl.clip.x=0;sdl.clip.y=0;
+		sdl.surface=SDL_SetVideoMode_Wrap(out_w,out_h,bpp, sfcflags);
+#ifdef WIN32
+		if (sdl.surface == NULL) {
+			SDL_QuitSubSystem(SDL_INIT_VIDEO);
+			if (!sdl.using_windib) {
+				LOG_MSG("Failed to create hardware surface.\nRestarting video subsystem with windib enabled.");
+				putenv("SDL_VIDEODRIVER=windib");
+				sdl.using_windib=true;
+			} else {
+				LOG_MSG("Failed to create hardware surface.\nRestarting video subsystem with directx enabled.");
+				putenv("SDL_VIDEODRIVER=directx");
+				sdl.using_windib=false;
+			}
+			SDL_InitSubSystem(SDL_INIT_VIDEO);
+			GFX_SetIcon(); //Set Icon again
+			sdl.surface = SDL_SetVideoMode_Wrap(out_w,out_h,bpp,SDL_HWSURFACE);
+			if(sdl.surface) GFX_SetTitle(-1,-1,false); //refresh title.
+		}
+#endif
+		if (sdl.surface == NULL)
+			E_Exit("Could not set windowed video mode %ix%i-%i: %s",(int)width,(int)height,bpp,SDL_GetError());
+	}
+	if (sdl.surface) {
+		switch (sdl.surface->format->BitsPerPixel) {
+		case 8:
+			*retFlags = GFX_CAN_8;
+				 break;
+		case 15:
+			*retFlags = GFX_CAN_15;
+			break;
+		case 16:
+			*retFlags = GFX_CAN_16;
+				 break;
+		case 32:
+			*retFlags = GFX_CAN_32;
+				 break;
+		}
+		if (*retFlags && (sdl.surface->flags & SDL_HWSURFACE))
+			*retFlags |= GFX_HARDWARE;
+		if (*retFlags && (sdl.surface->flags & SDL_DOUBLEBUF)) {
+		//if( 1==1 ) { //force blit surface for debuggin
+			sdl.blit.surface=SDL_CreateRGBSurface(SDL_HWSURFACE,
+				sdl.clip.w, sdl.clip.h,
+				sdl.surface->format->BitsPerPixel,
+				sdl.surface->format->Rmask,
+				sdl.surface->format->Gmask,
+				sdl.surface->format->Bmask,
+			0);
+			/* If this one fails be ready for some flickering... */
+		}
+	}
+	SDL_Rect rect;
+	rect.x = 0; rect.y = 0; rect.w = sdl.surface->w; rect.h = sdl.surface->h;
+	return 1; // Success
+}
+
+
+char ssStartUpdate( Bit8u **pixels, Bitu *pitch )
+{	return sdl.SurfaceInfo.StartUpdate( pixels, pitch );  }
+
+void ssEndUpdate( const Bit16u *changedLines )
+{	GetChangedLines( changedLines );
+	sdl.SurfaceInfo.EndUpdate(); // Output processed image if using buffer and scale the rectangles.
+	ssImageToScreen();
+}
+
+// Rectangles must already be calculated and if necessary--scaled.
+Bitu ssGetRgb( Bit8u red, Bit8u green, Bit8u blue )
+{	return SDL_MapRGB(sdl.surface->format,red,green,blue);  }
+
+Bitu soBestMode( Bitu *flags )
+{	Bitu testbpp;
+
+	//We only accept 32bit output from the scalers here
+	//Can't handle true color inputs
+	if( *flags & GFX_RGBONLY || !( *flags & GFX_CAN_32 ) )
+	{	testbpp = CheckSurface( flags );  }
+	else
+	{	*flags|=GFX_SCALING;
+		*flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
+		testbpp = 0;
+	}
+	return testbpp;
+}
+
+char soSetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley, Bitu *retFlags){	if (sdl.overlay) {
+		SDL_FreeYUVOverlay(sdl.overlay);
+		sdl.overlay=0;
+	}
+
+	if (!(flags&GFX_CAN_32) || (flags & GFX_RGBONLY)) return 0;
+	if (!GFX_SetupSurfaceScaled(flags, 0,0)) return 0;
+
+	int width_out  = 2 * width;
+	int height_out =     height;
+	sdl.overlay=SDL_CreateYUVOverlay(width_out,height_out,SDL_UYVY_OVERLAY,sdl.surface);
+	if (!sdl.overlay) {
+		LOG_MSG("SDL:Failed to create overlay, switching back to surface");
+		return 0;
+	}
+	
+	SDL_LockYUVOverlay( sdl.overlay );
+	char* cursor = (char*)sdl.overlay->pixels[0];
+	// TODO: Handle margins in sdl.clip and remove this:
+	for( long i = 0; i < sdl.overlay->pitches[0]/4*sdl.overlay->h; i++ ) // This is a one time procedure, so it needs no optimization.
+	{	*cursor++ = 128;
+		*cursor++ = 0;
+		*cursor++ = 128;
+		*cursor++ = 0;
+	}
+	SDL_UnlockYUVOverlay( sdl.overlay );
+	if( SDL_MUSTLOCK( sdl.surface ) )
+	{	SDL_LockSurface( sdl.surface );  }
+	int scanLen = sdl.surface->pitch;
+	cursor = (char*)sdl.surface->pixels;
+	for( int i = 0; i < sdl.surface->h; i++ )
+	{	for( int x = 0; x < scanLen; x++ )
+		{	*cursor++ = 0;  }
+	}
+	if( SDL_MUSTLOCK( sdl.surface ) )
+	{	SDL_UnlockSurface( sdl.surface );  }
+	*retFlags = GFX_CAN_32 | GFX_SCALING | GFX_HARDWARE;
+	return 1;
+}
+
+char soStartUpdate( Bit8u **pixels, Bitu *pitch )
+{	while( 1==1 ) //HACK: No idea why several attempts may be required. People at #SDL couldn't help
+	{	if (SDL_LockYUVOverlay(sdl.overlay))
+		{	continue;  }
 		break;
+	}
+	if (SDL_MUSTLOCK( sdl.surface ) )
+	{	if( SDL_LockSurface( sdl.surface ) )
+		{	return 0; }
+	}
+	*pixels = sdl.overlay->pixels [0];
+	*pitch  = sdl.overlay->pitches[0];
+	return 1;
+}
+
+void soApplyOverlay( SDL_Overlay *overlay )
+{	SDL_UnlockYUVOverlay(overlay);
+	if( SDL_MUSTLOCK( sdl.surface ) )
+	{	SDL_UnlockSurface(sdl.surface);  }
+	SDL_DisplayYUVOverlay(overlay,&sdl.clip);
+}
+
+void soEndUpdate( const Bit16u *changedLines )
+{	soApplyOverlay( sdl.overlay );  }
+
+Bitu soGetRgb( Bit8u red, Bit8u green, Bit8u blue )
+{	Bit8u y =  ( 9797*(red) + 19237*(green) +  3734*(blue) ) >> 15;
+	Bit8u u =  (18492*((blue)-(y)) >> 15) + 128;
+	Bit8u v =  (23372*((red)-(y)) >> 15) + 128;
+#ifdef WORDS_BIGENDIAN
+	return (y << 0) | (v << 8) | (y << 16) | (u << 24);
+#else
+	return (u << 0) | (y << 8) | (v << 16) | (y << 24);
+#endif
+}
+
+Bitu ogBestMode( Bitu *flags )
+{	Bitu testbpp;
+	//We only accept 32bit output from the scalers here
+	if( !( *flags & GFX_CAN_32 ) ) 
+	{	testbpp = CheckSurface( flags );  }
+	else
+	{	*flags|=GFX_SCALING;
+		*flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
+		testbpp = 0;
+	}
+	if( sdl.opengl.kind == GlkPerfect )
+	{	*flags |= GFX_UNITY_SCALE;  }
+	return testbpp;
+}
+
+static void setvsync( bool on )
+{	const char * state;
+	int res;
+	if( on ) state = "on";
+	else     state = "off";
+#if SDL_VERSION_ATLEAST(1,3,0)
+	if( on )
+	{						res = SDL_GL_SetSwapInterval(-1);
+		if( res != 0 ) res = SDL_GL_SetSwapInterval( 1);
+	}
+	else res = SDL_GL_SetSwapInterval( 0 );
+#else
+#if SDL_VERSION_ATLEAST(1,2,11)
+	res = SDL_GL_SetAttribute( SDL_GL_SWAP_CONTROL, on );
+#else
+	if( on )
+		LOG_MSG("...V-Sync not supported in this version of SDL.");
+#define SDL_NOVSYNC
+#endif
+#endif
+#ifndef SDL_NOVSYNC
+	if( res == 0 ) LOG_MSG("V-Sync turned %s.", state); else
+	               LOG_MSG("Failed to turn V-Sync %s: %s", state, SDL_GetError());
+#endif
+}
+
+char ogSetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley, Bitu *retFlags) {
+	if (sdl.opengl.pixel_buffer_object) {
+		glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
+		if (sdl.opengl.buffer) glDeleteBuffersARB(1, &sdl.opengl.buffer);
+	} else if (sdl.opengl.framebuf) {
+		free(sdl.opengl.framebuf);
+	}
+	sdl.opengl.framebuf=0;
+	if( !( flags & GFX_CAN_32 ) ) return 0;
+	int texsize=2 << int_log2(width > height ? width : height);
+	if (texsize>sdl.opengl.max_texsize) {
+		LOG_MSG("SDL:OPENGL:No support for texturesize of %d, falling back to surface",texsize);
+		return 0;
+	}
+	SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
+	setvsync( sdl.opengl.vsync && sdl.desktop.fullscreen && !sdl.desktop.fullborderless );
+	if( sdl.opengl.kind == GlkPerfect )
+	{	Bit16u avh, avw, w, h;
+		bool fixed;
+		ps_size szin, szout, szres;
+		ps_info ps;
+		avw = width; avh = height;
+		GetAvailableArea( &avw, &avh, &fixed );
+		szin .w = width; szin .h = height;
+		szout.w = avw;   szout.h = avh;
+		LOG_MSG("Available area: %ix%i", avw, avh);
+		ps = ps_new_perfect
+		(	rgb_32_fmt_in,   szin,
+			rgb_32_fmt_out,  szout,
+			sdl.dbl_w,       sdl.dbl_h, 3,
+			sdl.draw.aspect, &szres
+		);
+		ps_free( ps );
+		double scalex = (double)szres.w/szin.w;
+		double scaley = (double)szres.h/szin.h;
+		LOG_MSG
+		(	"Scaling: %ix%i (%4.2f) --[%3.1f x %3.1f]--> %4ix%-4i (%4.2f)",
+			szin.w, szin.h, sdl.draw.aspect, scalex, scaley, szres.w, szres.h, scaley/scalex
+		);
+		Bit32u sdl_flags = genflags(flags) | SDL_OPENGL;
+		sdl.clip.x = 0; sdl.clip.y = 0;
+		if( sdl.desktop.fullscreen )
+		{	sdl.clip.w = szres.w; sdl.clip.h = szres.h;
+			w = avw; h = avh;
+		}
+		else
+		{	sdl.clip.w = szres.w; sdl.clip.h = szres.h;
+			w          = szres.w; h          = szres.h;
+		}
+		sdl.surface = SDL_SetVideoMode_Wrap( w, h, 0, sdl_flags);
+	}
+	else GFX_SetupSurfaceScaled(flags, SDL_OPENGL,0);
+	if (!sdl.surface || sdl.surface->format->BitsPerPixel<15) {
+		LOG_MSG("SDL:OPENGL:Can't open drawing surface, are you running in 16bpp(or higher) mode?");
+		return 0;
+	}
+
+	/* Create the texture and display list */
+	if (sdl.opengl.pixel_buffer_object) {
+		glGenBuffersARB(1, &sdl.opengl.buffer);
+		glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, sdl.opengl.buffer);
+		glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_EXT, width*height*4, NULL, GL_STREAM_DRAW_ARB);
+		glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
+	} else {
+		sdl.opengl.framebuf=malloc(width*height*4);		//32 bit color
+	}
+	sdl.opengl.pitch=width*4;
+	if
+	(	sdl.clip.x == 0 && sdl.clip.y == 0 &&
+		(	sdl.clip.w != sdl.surface->w || sdl.clip.h != sdl.surface->h)
+	)
+	{	LOG_MSG("attempting to fix the centering to %d %d %d %d",(sdl.surface->w-sdl.clip.w)/2,(sdl.surface->h-sdl.clip.h)/2,sdl.clip.w,sdl.clip.h);
+		glViewport((sdl.surface->w-sdl.clip.w)/2,(sdl.surface->h-sdl.clip.h)/2,sdl.clip.w,sdl.clip.h);
+	}
+	else
+	{	glViewport(sdl.clip.x,sdl.clip.y,sdl.clip.w,sdl.clip.h);  }		
+
+	glMatrixMode (GL_PROJECTION);
+	glDeleteTextures(1,&sdl.opengl.texture);
+	glGenTextures(1,&sdl.opengl.texture);
+	glBindTexture(GL_TEXTURE_2D,sdl.opengl.texture);
+	// No borders
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+	if (!sdl.opengl.kind == GlkBilinear || ( (sdl.clip.h % height) == 0 && (sdl.clip.w % width) == 0) ) {
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+	} else {
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+	}
+
+	Bit8u* emptytex = new Bit8u[texsize * texsize * 4];
+	memset((void*) emptytex, 0, texsize * texsize * 4);
+	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, texsize, texsize, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, (const GLvoid*)emptytex);
+	delete [] emptytex;
+
+	//glClearColor (0.0, 0.0, 0.0, 1.0);
+	//glClear(GL_COLOR_BUFFER_BIT);
+	//SDL_GL_SwapBuffers();
+	//glClear(GL_COLOR_BUFFER_BIT);
+	glShadeModel (GL_FLAT);
+	glDisable (GL_DEPTH_TEST);
+	glDisable (GL_LIGHTING);
+	glDisable(GL_CULL_FACE);
+	glEnable(GL_TEXTURE_2D);
+	glMatrixMode (GL_MODELVIEW);
+	glLoadIdentity ();
+
+	GLfloat tex_width=((GLfloat)(width)/(GLfloat)texsize);
+	GLfloat tex_height=((GLfloat)(height)/(GLfloat)texsize);
+
+	if (glIsList(sdl.opengl.displaylist)) glDeleteLists(sdl.opengl.displaylist, 1);
+	sdl.opengl.displaylist = glGenLists(1);
+	glNewList(sdl.opengl.displaylist, GL_COMPILE);
+	glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
+	glBegin(GL_QUADS);
+	// lower left
+	glTexCoord2f(0,tex_height); glVertex2f(-1.0f,-1.0f);
+	// lower right
+	glTexCoord2f(tex_width,tex_height); glVertex2f(1.0f, -1.0f);
+	// upper right
+	glTexCoord2f(tex_width,0); glVertex2f(1.0f, 1.0f);
+	// upper left
+	glTexCoord2f(0,0); glVertex2f(-1.0f, 1.0f);
+	glEnd();
+	glEndList();
+	*retFlags = GFX_CAN_32 | GFX_SCALING;
+	if (sdl.opengl.pixel_buffer_object)
+		*retFlags |= GFX_HARDWARE;
+	return 1;
+}
+
+char ogStartUpdate( Bit8u **pixels, Bitu *pitch )
+{	if(sdl.opengl.pixel_buffer_object) {
+		 glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, sdl.opengl.buffer);
+		 *pixels=(Bit8u *)glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, GL_WRITE_ONLY);
+	} else
+		 *pixels=(Bit8u *)sdl.opengl.framebuf;
+	*pitch=sdl.opengl.pitch;
+	return 1;
+}
+
+void ogEndUpdate( const Bit16u *changedLines )
+{	// Clear drawing area. Some drivers (on Linux) have more than 2 buffers and the screen might
+	// be dirty because of other programs.
+	glClearColor (0.0, 0.0, 0.0, 1.0);
+	glClear(GL_COLOR_BUFFER_BIT);
+	if (sdl.opengl.pixel_buffer_object) {
+		glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT);
+		glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
+		glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0,
+				sdl.draw.width, sdl.draw.height, GL_BGRA_EXT,
+				GL_UNSIGNED_INT_8_8_8_8_REV, 0);
+		glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
+		glCallList(sdl.opengl.displaylist);
+		SDL_GL_SwapBuffers();
+	} else if (changedLines) {
+		Bitu y = 0, index = 0;
+		glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
+		while (y < sdl.draw.height) {
+			if (!(index & 1)) {
+				y += changedLines[index];
+			} else {
+				Bit8u *pixels = (Bit8u *)sdl.opengl.framebuf + y * sdl.opengl.pitch;
+				Bitu height = changedLines[index];
+				glTexSubImage2D(GL_TEXTURE_2D, 0, 0, y,
+					sdl.draw.width, height, GL_BGRA_EXT,
+					GL_UNSIGNED_INT_8_8_8_8_REV, pixels );
+				y += height;
+			}
+			index++;
+		}
+		glCallList(sdl.opengl.displaylist);
+		SDL_GL_SwapBuffers();
+	}
+}
+
+Bitu ogGetRgb( Bit8u red, Bit8u green, Bit8u blue )
+{	return ((blue << 0) | (green << 8) | (red << 16)) | (255 << 24);  }
+
+Bitu ssdBestMode( Bitu *flags )
+{	Bitu testbpp;
+	if (!(*flags&(GFX_CAN_15|GFX_CAN_16|GFX_CAN_32)))
+	{	testbpp = CheckSurface( &*flags );  }
+	else
+	{	if (*flags & GFX_LOVE_15)
+		{	testbpp=15;  }
+		else if (*flags & GFX_LOVE_16) testbpp=16;
+		else if (*flags & GFX_LOVE_32) testbpp=32;
+		else testbpp=0;
+		*flags|=GFX_SCALING;
+	}
+	return testbpp;
+}
+
 #if C_DDRAW
-	case SCREEN_SURFACE_DDRAW:
-		if (!(flags&(GFX_CAN_15|GFX_CAN_16|GFX_CAN_32))) goto check_surface;
-		if (flags & GFX_LOVE_15) testbpp=15;
-		else if (flags & GFX_LOVE_16) testbpp=16;
-		else if (flags & GFX_LOVE_32) testbpp=32;
-		else testbpp=0;
-		flags|=GFX_SCALING;
-		goto check_gotbpp;
-#endif
-	case SCREEN_OVERLAY:
-		//We only accept 32bit output from the scalers here
-		//Can't handle true color inputs
-		if (flags & GFX_RGBONLY || !(flags&GFX_CAN_32)) goto check_surface;
-		flags|=GFX_SCALING;
-		flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
+char ssdSetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley, Bitu *retFlags){
+	int bpp = 0;
+	if (flags & GFX_CAN_15) bpp=15;
+	if (flags & GFX_CAN_16) bpp=16;
+	if (flags & GFX_CAN_32) bpp=32;
+	if (!GFX_SetupSurfaceScaled(flags, 0,bpp))
+	{	return 0;  }
+	sdl.blit.rect.top=sdl.clip.y;
+	sdl.blit.rect.left=sdl.clip.x;
+	sdl.blit.rect.right=sdl.clip.x+sdl.clip.w;
+	sdl.blit.rect.bottom=sdl.clip.y+sdl.clip.h;
+	sdl.blit.surface=SDL_CreateRGBSurface(SDL_HWSURFACE,sdl.draw.width,sdl.draw.height,
+			sdl.surface->format->BitsPerPixel,
+			sdl.surface->format->Rmask,
+			sdl.surface->format->Gmask,
+			sdl.surface->format->Bmask,
+			0);
+	if (!sdl.blit.surface || (!sdl.blit.surface->flags&SDL_HWSURFACE)) {
+		if (sdl.blit.surface) {
+			SDL_FreeSurface(sdl.blit.surface);
+			sdl.blit.surface=0;
+		}
+		LOG_MSG("Failed to create ddraw surface, back to normal surface.");
+		return 0; // Error
+	}
+	switch (sdl.surface->format->BitsPerPixel) {
+	case 15:
+		*retFlags = GFX_CAN_15 | GFX_SCALING | GFX_HARDWARE;
 		break;
-#if C_OPENGL
-	case SCREEN_OPENGL:
-		//We only accept 32bit output from the scalers here
-		if (!(flags&GFX_CAN_32)) goto check_surface;
-		flags|=GFX_SCALING;
-		flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
+	case 16:
+		*retFlags = GFX_CAN_16 | GFX_SCALING | GFX_HARDWARE;
+				break;
+	case 32:
+		*retFlags = GFX_CAN_32 | GFX_SCALING | GFX_HARDWARE;
+				break;
+	}
+	return 1; // Success;
+}
+
+char ssdStartUpdate( Bit8u **pixels, Bitu *pitch )
+{	if (SDL_LockSurface(sdl.blit.surface)) {
+//			LOG_MSG("SDL Lock failed");
+		return 0;
+	}
+	*pixels=(Bit8u *)sdl.blit.surface->pixels;
+	*pitch=sdl.blit.surface->pitch;
+	return 1;
+}
+
+void ssdEndUpdate( const Bit16u *changedLines )
+{	int ret;
+	SDL_UnlockSurface(sdl.blit.surface);
+	ret=IDirectDrawSurface3_Blt(
+		sdl.surface->hwdata->dd_writebuf,&sdl.blit.rect,
+		sdl.blit.surface->hwdata->dd_surface,0,
+		DDBLT_WAIT, NULL);
+	switch (ret) {
+	case DD_OK:
 		break;
-#endif
+	case DDERR_SURFACELOST:
+		IDirectDrawSurface3_Restore(sdl.blit.surface->hwdata->dd_surface);
+		IDirectDrawSurface3_Restore(sdl.surface->hwdata->dd_surface);
+		break;
 	default:
-		goto check_surface;
-		break;
+		LOG_MSG("DDRAW:Failed to blit, error %X",ret);
 	}
+	SDL_Flip(sdl.surface);
+}
+
+Bitu ssdGetRgb( Bit8u red, Bit8u green, Bit8u blue )
+{	return SDL_MapRGB(sdl.surface->format,red,green,blue);  }
+#endif
+
+ScreenTypeInfo info[10];
+void AddScreenType( SCREEN_TYPES type, FGetBestMode bm, FSetSize ss, FStartUpdate su, FEndUpdate eu, FGetRgb gr )
+{	PScreenTypeInfo st = &info[type];
+	st->GetBestMode = bm;
+	st->SetSize     = ss;
+	st->StartUpdate = su;
+	st->EndUpdate   = eu;
+	st->GetRgb      = gr;
+}
+
+void InitScreenTypes()
+{	AddScreenType( SCREEN_SURFACE,        &ssBestMode,  &ssSetSize,  &ssStartUpdate, &ssEndUpdate, &ssGetRgb );
+	AddScreenType( SCREEN_OVERLAY,        &soBestMode,  &soSetSize,  &soStartUpdate, &soEndUpdate, &soGetRgb );
+	AddScreenType( SCREEN_OPENGL,         &ogBestMode,  &ogSetSize,  &ogStartUpdate, &ogEndUpdate, &ogGetRgb );
+#if C_DDRAW
+	AddScreenType( SCREEN_SURFACE_DDRAW,  &ssdBestMode, &ssdSetSize, &ssdStartUpdate, &ssdEndUpdate,&ssdGetRgb );
+#endif
+}
+
+char stInited = 0;
+PScreenTypeInfo GetScreenTypeInfo( SCREEN_TYPES type )
+{	if( !stInited )
+	{	stInited = 1;
+		InitScreenTypes();
+	}
+	// This precaution is redundant because the availability of DDRAW is tested
+	// at compile time, and that too is redundant (repeated use of #if C_DDRAW
+	if( info[ type ].GetBestMode == NULL)	{	type = SCREEN_SURFACE;  }
+	return &(info[ type ]);
+}
+
+/* Reset the screen with current values in the sdl structure */
+Bitu GFX_GetBestMode(Bitu flags) {
+	int testbpp = GetScreenTypeInfo( sdl.desktop.want_type)->GetBestMode(&flags);
+	if( testbpp )
+	{	CheckGotBpp( &flags, testbpp );  }
 	return flags;
 }
 
@@ -455,27 +1327,20 @@
 	}
 }
 
-static int int_log2 (int val) {
-    int log = 0;
-    while ((val >>= 1) != 0)
-	log++;
-    return log;
-}
 
-
-static SDL_Surface * GFX_SetupSurfaceScaled(Bit32u sdl_flags, Bit32u bpp) {
+static SDL_Surface * GFX_SetupSurfaceScaled(Bitu flags, Bit32u sdl_flags, Bit32u bpp) {
 	Bit16u fixedWidth;
 	Bit16u fixedHeight;
 
+	sdl_flags |= genflags(flags);
 	if (sdl.desktop.fullscreen) {
 		fixedWidth = sdl.desktop.full.fixed ? sdl.desktop.full.width : 0;
 		fixedHeight = sdl.desktop.full.fixed ? sdl.desktop.full.height : 0;
-		sdl_flags |= SDL_FULLSCREEN|SDL_HWSURFACE;
 	} else {
 		fixedWidth = sdl.desktop.window.width;
 		fixedHeight = sdl.desktop.window.height;
-		sdl_flags |= SDL_HWSURFACE;
 	}
+
 	if (fixedWidth && fixedHeight) {
 		double ratio_w=(double)fixedWidth/(sdl.draw.width*sdl.draw.scalex);
 		double ratio_h=(double)fixedHeight/(sdl.draw.height*sdl.draw.scaley);
@@ -501,14 +1366,13 @@
 			sdl.clip.x = 0;
 			sdl.clip.y = 0;
 		}
-		return sdl.surface;
 	} else {
 		sdl.clip.x=0;sdl.clip.y=0;
 		sdl.clip.w=(Bit16u)(sdl.draw.width*sdl.draw.scalex);
 		sdl.clip.h=(Bit16u)(sdl.draw.height*sdl.draw.scaley);
 		sdl.surface=SDL_SetVideoMode_Wrap(sdl.clip.w,sdl.clip.h,bpp,sdl_flags);
-		return sdl.surface;
 	}
+	return sdl.surface;
 }
 
 void GFX_TearDown(void) {
@@ -521,16 +1385,20 @@
 	}
 }
 
-Bitu GFX_SetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley,GFX_CallBack_t callback) {
+Bitu GFX_SetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley,GFX_CallBack_t callback, double aspect ) {
 	if (sdl.updating)
 		GFX_EndUpdate( 0 );
 
 	sdl.draw.width=width;
 	sdl.draw.height=height;
+	sdl.draw.aspect=aspect;
 	sdl.draw.callback=callback;
 	sdl.draw.scalex=scalex;
 	sdl.draw.scaley=scaley;
 
+	sdl.dbl_h = ( flags & GFX_DBL_H ) > 0;
+	sdl.dbl_w = ( flags & GFX_DBL_W ) > 0;
+
 	int bpp=0;
 	Bitu retFlags = 0;
 
@@ -538,243 +1406,15 @@
 		SDL_FreeSurface(sdl.blit.surface);
 		sdl.blit.surface=0;
 	}
-	switch (sdl.desktop.want_type) {
-	case SCREEN_SURFACE:
-dosurface:
-		if (flags & GFX_CAN_8) bpp=8;
-		if (flags & GFX_CAN_15) bpp=15;
-		if (flags & GFX_CAN_16) bpp=16;
-		if (flags & GFX_CAN_32) bpp=32;
-		sdl.desktop.type=SCREEN_SURFACE;
-		sdl.clip.w=width;
-		sdl.clip.h=height;
-		if (sdl.desktop.fullscreen) {
-			if (sdl.desktop.full.fixed) {
-				sdl.clip.x=(Sint16)((sdl.desktop.full.width-width)/2);
-				sdl.clip.y=(Sint16)((sdl.desktop.full.height-height)/2);
-				sdl.surface=SDL_SetVideoMode_Wrap(sdl.desktop.full.width,sdl.desktop.full.height,bpp,
-					SDL_FULLSCREEN | ((flags & GFX_CAN_RANDOM) ? SDL_SWSURFACE : SDL_HWSURFACE) |
-					(sdl.desktop.doublebuf ? SDL_DOUBLEBUF|SDL_ASYNCBLIT : 0) | SDL_HWPALETTE);
-				if (sdl.surface == NULL) E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",sdl.desktop.full.width,sdl.desktop.full.height,bpp,SDL_GetError());
-			} else {
-				sdl.clip.x=0;sdl.clip.y=0;
-				sdl.surface=SDL_SetVideoMode_Wrap(width,height,bpp,
-					SDL_FULLSCREEN | ((flags & GFX_CAN_RANDOM) ? SDL_SWSURFACE : SDL_HWSURFACE) |
-					(sdl.desktop.doublebuf ? SDL_DOUBLEBUF|SDL_ASYNCBLIT  : 0)|SDL_HWPALETTE);
-				if (sdl.surface == NULL)
-					E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",(int)width,(int)height,bpp,SDL_GetError());
-			}
-		} else {
-			sdl.clip.x=0;sdl.clip.y=0;
-			sdl.surface=SDL_SetVideoMode_Wrap(width,height,bpp,(flags & GFX_CAN_RANDOM) ? SDL_SWSURFACE : SDL_HWSURFACE);
-#ifdef WIN32
-			if (sdl.surface == NULL) {
-				SDL_QuitSubSystem(SDL_INIT_VIDEO);
-				if (!sdl.using_windib) {
-					LOG_MSG("Failed to create hardware surface.\nRestarting video subsystem with windib enabled.");
-					putenv("SDL_VIDEODRIVER=windib");
-					sdl.using_windib=true;
-				} else {
-					LOG_MSG("Failed to create hardware surface.\nRestarting video subsystem with directx enabled.");
-					putenv("SDL_VIDEODRIVER=directx");
-					sdl.using_windib=false;
-				}
-				SDL_InitSubSystem(SDL_INIT_VIDEO);
-				GFX_SetIcon(); //Set Icon again
-				sdl.surface = SDL_SetVideoMode_Wrap(width,height,bpp,SDL_HWSURFACE);
-				if(sdl.surface) GFX_SetTitle(-1,-1,false); //refresh title.
-			}
-#endif
-			if (sdl.surface == NULL)
-				E_Exit("Could not set windowed video mode %ix%i-%i: %s",(int)width,(int)height,bpp,SDL_GetError());
-		}
-		if (sdl.surface) {
-			switch (sdl.surface->format->BitsPerPixel) {
-			case 8:
-				retFlags = GFX_CAN_8;
-                break;
-			case 15:
-				retFlags = GFX_CAN_15;
-				break;
-			case 16:
-				retFlags = GFX_CAN_16;
-                break;
-			case 32:
-				retFlags = GFX_CAN_32;
-                break;
-			}
-			if (retFlags && (sdl.surface->flags & SDL_HWSURFACE))
-				retFlags |= GFX_HARDWARE;
-			if (retFlags && (sdl.surface->flags & SDL_DOUBLEBUF)) {
-				sdl.blit.surface=SDL_CreateRGBSurface(SDL_HWSURFACE,
-					sdl.draw.width, sdl.draw.height,
-					sdl.surface->format->BitsPerPixel,
-					sdl.surface->format->Rmask,
-					sdl.surface->format->Gmask,
-					sdl.surface->format->Bmask,
-				0);
-				/* If this one fails be ready for some flickering... */
-			}
-		}
-		break;
-#if C_DDRAW
-	case SCREEN_SURFACE_DDRAW:
-		if (flags & GFX_CAN_15) bpp=15;
-		if (flags & GFX_CAN_16) bpp=16;
-		if (flags & GFX_CAN_32) bpp=32;
-		if (!GFX_SetupSurfaceScaled((sdl.desktop.doublebuf && sdl.desktop.fullscreen) ? SDL_DOUBLEBUF : 0,bpp)) goto dosurface;
-		sdl.blit.rect.top=sdl.clip.y;
-		sdl.blit.rect.left=sdl.clip.x;
-		sdl.blit.rect.right=sdl.clip.x+sdl.clip.w;
-		sdl.blit.rect.bottom=sdl.clip.y+sdl.clip.h;
-		sdl.blit.surface=SDL_CreateRGBSurface(SDL_HWSURFACE,sdl.draw.width,sdl.draw.height,
-				sdl.surface->format->BitsPerPixel,
-				sdl.surface->format->Rmask,
-				sdl.surface->format->Gmask,
-				sdl.surface->format->Bmask,
-				0);
-		if (!sdl.blit.surface || (!sdl.blit.surface->flags&SDL_HWSURFACE)) {
-			if (sdl.blit.surface) {
-				SDL_FreeSurface(sdl.blit.surface);
-				sdl.blit.surface=0;
-			}
-			LOG_MSG("Failed to create ddraw surface, back to normal surface.");
-			goto dosurface;
-		}
-		switch (sdl.surface->format->BitsPerPixel) {
-		case 15:
-			retFlags = GFX_CAN_15 | GFX_SCALING | GFX_HARDWARE;
-			break;
-		case 16:
-			retFlags = GFX_CAN_16 | GFX_SCALING | GFX_HARDWARE;
-               break;
-		case 32:
-			retFlags = GFX_CAN_32 | GFX_SCALING | GFX_HARDWARE;
-               break;
-		}
-		sdl.desktop.type=SCREEN_SURFACE_DDRAW;
-		break;
-#endif
-	case SCREEN_OVERLAY:
-		if (sdl.overlay) {
-			SDL_FreeYUVOverlay(sdl.overlay);
-			sdl.overlay=0;
-		}
-		if (!(flags&GFX_CAN_32) || (flags & GFX_RGBONLY)) goto dosurface;
-		if (!GFX_SetupSurfaceScaled(0,0)) goto dosurface;
-		sdl.overlay=SDL_CreateYUVOverlay(width*2,height,SDL_UYVY_OVERLAY,sdl.surface);
-		if (!sdl.overlay) {
-			LOG_MSG("SDL: Failed to create overlay, switching back to surface");
-			goto dosurface;
-		}
-		sdl.desktop.type=SCREEN_OVERLAY;
-		retFlags = GFX_CAN_32 | GFX_SCALING | GFX_HARDWARE;
-		break;
-#if C_OPENGL
-	case SCREEN_OPENGL:
-	{
-		if (sdl.opengl.pixel_buffer_object) {
-			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
-			if (sdl.opengl.buffer) glDeleteBuffersARB(1, &sdl.opengl.buffer);
-		} else if (sdl.opengl.framebuf) {
-			free(sdl.opengl.framebuf);
-		}
-		sdl.opengl.framebuf=0;
-		if (!(flags&GFX_CAN_32)) goto dosurface;
-		int texsize=2 << int_log2(width > height ? width : height);
-		if (texsize>sdl.opengl.max_texsize) {
-			LOG_MSG("SDL:OPENGL: No support for texturesize of %d, falling back to surface",texsize);
-			goto dosurface;
-		}
-		SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
-#if SDL_VERSION_ATLEAST(1, 2, 11)
-		SDL_GL_SetAttribute( SDL_GL_SWAP_CONTROL, 0 );
-#endif
-		GFX_SetupSurfaceScaled(SDL_OPENGL,0);
-		if (!sdl.surface || sdl.surface->format->BitsPerPixel<15) {
-			LOG_MSG("SDL:OPENGL: Can't open drawing surface, are you running in 16bpp (or higher) mode?");
-			goto dosurface;
-		}
-		/* Create the texture and display list */
-		if (sdl.opengl.pixel_buffer_object) {
-			glGenBuffersARB(1, &sdl.opengl.buffer);
-			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, sdl.opengl.buffer);
-			glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_EXT, width*height*4, NULL, GL_STREAM_DRAW_ARB);
-			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
-		} else {
-			sdl.opengl.framebuf=malloc(width*height*4);		//32 bit color
-		}
-		sdl.opengl.pitch=width*4;
 
-		if(sdl.clip.x ==0 && sdl.clip.y ==0 && sdl.desktop.fullscreen && !sdl.desktop.full.fixed && (sdl.clip.w != sdl.surface->w || sdl.clip.h != sdl.surface->h)) { 
-//			LOG_MSG("attempting to fix the centering to %d %d %d %d",(sdl.surface->w-sdl.clip.w)/2,(sdl.surface->h-sdl.clip.h)/2,sdl.clip.w,sdl.clip.h);
-			glViewport((sdl.surface->w-sdl.clip.w)/2,(sdl.surface->h-sdl.clip.h)/2,sdl.clip.w,sdl.clip.h);
-		} else {
-			glViewport(sdl.clip.x,sdl.clip.y,sdl.clip.w,sdl.clip.h);
-		}		
-
-		glMatrixMode (GL_PROJECTION);
-		glDeleteTextures(1,&sdl.opengl.texture);
- 		glGenTextures(1,&sdl.opengl.texture);
-		glBindTexture(GL_TEXTURE_2D,sdl.opengl.texture);
-		// No borders
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-		if (!sdl.opengl.bilinear || ( (sdl.clip.h % height) == 0 && (sdl.clip.w % width) == 0) ) {
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-		} else {
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-		}
-
-		Bit8u* emptytex = new Bit8u[texsize * texsize * 4];
-		memset((void*) emptytex, 0, texsize * texsize * 4);
-		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, texsize, texsize, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, (const GLvoid*)emptytex);
-		delete [] emptytex;
-
-		glClearColor (0.0, 0.0, 0.0, 1.0);
-		glClear(GL_COLOR_BUFFER_BIT);
-		SDL_GL_SwapBuffers();
-		glClear(GL_COLOR_BUFFER_BIT);
-		glShadeModel (GL_FLAT);
-		glDisable (GL_DEPTH_TEST);
-		glDisable (GL_LIGHTING);
-		glDisable(GL_CULL_FACE);
-		glEnable(GL_TEXTURE_2D);
-		glMatrixMode (GL_MODELVIEW);
-		glLoadIdentity ();
-
-		GLfloat tex_width=((GLfloat)(width)/(GLfloat)texsize);
-		GLfloat tex_height=((GLfloat)(height)/(GLfloat)texsize);
-
-		if (glIsList(sdl.opengl.displaylist)) glDeleteLists(sdl.opengl.displaylist, 1);
-		sdl.opengl.displaylist = glGenLists(1);
-		glNewList(sdl.opengl.displaylist, GL_COMPILE);
-		glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
-		glBegin(GL_QUADS);
-		// lower left
-		glTexCoord2f(0,tex_height); glVertex2f(-1.0f,-1.0f);
-		// lower right
-		glTexCoord2f(tex_width,tex_height); glVertex2f(1.0f, -1.0f);
-		// upper right
-		glTexCoord2f(tex_width,0); glVertex2f(1.0f, 1.0f);
-		// upper left
-		glTexCoord2f(0,0); glVertex2f(-1.0f, 1.0f);
-		glEnd();
-		glEndList();
-		sdl.desktop.type=SCREEN_OPENGL;
-		retFlags = GFX_CAN_32 | GFX_SCALING;
-		if (sdl.opengl.pixel_buffer_object)
-			retFlags |= GFX_HARDWARE;
-	break;
-		}//OPENGL
-#endif	//C_OPENGL
-	default:
-		goto dosurface;
-		break;
-	}//CASE
-	if (retFlags)
+	ScreenTypeInfo* screen;
+	screen = GetScreenTypeInfo( sdl.desktop.want_type );
+	if( screen->SetSize(width, height, flags, scalex, scaley, &retFlags) )
+	{	goto success;  }
+	screen  = GetScreenTypeInfo( SCREEN_SURFACE ); // Backup
+	screen->SetSize(width, height, flags, scalex, scaley, &retFlags);
+success:
+	sdl.desktop.screen = *screen;	if (retFlags)
 		GFX_Start();
 	if (!sdl.mouse.autoenable) SDL_ShowCursor(sdl.mouse.autolock?SDL_DISABLE:SDL_ENABLE);
 	return retFlags;
@@ -876,7 +1516,7 @@
 }
 
 void GFX_RestoreMode(void) {
-	GFX_SetSize(sdl.draw.width,sdl.draw.height,sdl.draw.flags,sdl.draw.scalex,sdl.draw.scaley,sdl.draw.callback);
+	GFX_SetSize(sdl.draw.width,sdl.draw.height,sdl.draw.flags,sdl.draw.scalex,sdl.draw.scaley,sdl.draw.callback, sdl.draw.aspect); //TODO: Is passing sdl.aspect correct here?
 	GFX_UpdateSDLCaptureState();
 }
 
@@ -883,167 +1523,21 @@
 
 bool GFX_StartUpdate(Bit8u * & pixels,Bitu & pitch) {
 	if (!sdl.active || sdl.updating)
-		return false;
-	switch (sdl.desktop.type) {
-	case SCREEN_SURFACE:
-		if (sdl.blit.surface) {
-			if (SDL_MUSTLOCK(sdl.blit.surface) && SDL_LockSurface(sdl.blit.surface))
-				return false;
-			pixels=(Bit8u *)sdl.blit.surface->pixels;
-			pitch=sdl.blit.surface->pitch;
-		} else {
-			if (SDL_MUSTLOCK(sdl.surface) && SDL_LockSurface(sdl.surface))
-				return false;
-			pixels=(Bit8u *)sdl.surface->pixels;
-			pixels+=sdl.clip.y*sdl.surface->pitch;
-			pixels+=sdl.clip.x*sdl.surface->format->BytesPerPixel;
-			pitch=sdl.surface->pitch;
-		}
-		sdl.updating=true;
-		return true;
-#if C_DDRAW
-	case SCREEN_SURFACE_DDRAW:
-		if (SDL_LockSurface(sdl.blit.surface)) {
-//			LOG_MSG("SDL Lock failed");
-			return false;
-		}
-		pixels=(Bit8u *)sdl.blit.surface->pixels;
-		pitch=sdl.blit.surface->pitch;
-		sdl.updating=true;
-		return true;
-#endif
-	case SCREEN_OVERLAY:
-		if (SDL_LockYUVOverlay(sdl.overlay)) return false;
-		pixels=(Bit8u *)*(sdl.overlay->pixels);
-		pitch=*(sdl.overlay->pitches);
-		sdl.updating=true;
-		return true;
-#if C_OPENGL
-	case SCREEN_OPENGL:
-		if(sdl.opengl.pixel_buffer_object) {
-		    glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, sdl.opengl.buffer);
-		    pixels=(Bit8u *)glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, GL_WRITE_ONLY);
-		} else
-		    pixels=(Bit8u *)sdl.opengl.framebuf;
-		pitch=sdl.opengl.pitch;
-		sdl.updating=true;
-		return true;
-#endif
-	default:
-		break;
-	}
-	return false;
+	{	return false;  }
+	if( !sdl.desktop.screen.StartUpdate( &pixels, &pitch ) )
+	{	return false;  }
+	sdl.updating = true;
+	return true;
 }
 
 
 void GFX_EndUpdate( const Bit16u *changedLines ) {
-#if C_DDRAW
-	int ret;
-#endif
 	if (!sdl.updating)
 		return;
 	sdl.updating=false;
-	switch (sdl.desktop.type) {
-	case SCREEN_SURFACE:
-		if (SDL_MUSTLOCK(sdl.surface)) {
-			if (sdl.blit.surface) {
-				SDL_UnlockSurface(sdl.blit.surface);
-				int Blit = SDL_BlitSurface( sdl.blit.surface, 0, sdl.surface, &sdl.clip );
-				LOG(LOG_MISC,LOG_WARN)("BlitSurface returned %d",Blit);
-			} else {
-				SDL_UnlockSurface(sdl.surface);
-			}
-			SDL_Flip(sdl.surface);
-		} else if (changedLines) {
-			Bitu y = 0, index = 0, rectCount = 0;
-			while (y < sdl.draw.height) {
-				if (!(index & 1)) {
-					y += changedLines[index];
-				} else {
-					SDL_Rect *rect = &sdl.updateRects[rectCount++];
-					rect->x = sdl.clip.x;
-					rect->y = sdl.clip.y + y;
-					rect->w = (Bit16u)sdl.draw.width;
-					rect->h = changedLines[index];
-#if 0
-					if (rect->h + rect->y > sdl.surface->h) {
-						LOG_MSG("WTF %d +  %d  >%d",rect->h,rect->y,sdl.surface->h);
-					}
-#endif
-					y += changedLines[index];
-				}
-				index++;
-			}
-			if (rectCount)
-				SDL_UpdateRects( sdl.surface, rectCount, sdl.updateRects );
-		}
-		break;
-#if C_DDRAW
-	case SCREEN_SURFACE_DDRAW:
-		SDL_UnlockSurface(sdl.blit.surface);
-		ret=IDirectDrawSurface3_Blt(
-			sdl.surface->hwdata->dd_writebuf,&sdl.blit.rect,
-			sdl.blit.surface->hwdata->dd_surface,0,
-			DDBLT_WAIT, NULL);
-		switch (ret) {
-		case DD_OK:
-			break;
-		case DDERR_SURFACELOST:
-			IDirectDrawSurface3_Restore(sdl.blit.surface->hwdata->dd_surface);
-			IDirectDrawSurface3_Restore(sdl.surface->hwdata->dd_surface);
-			break;
-		default:
-			LOG_MSG("DDRAW: Failed to blit, error %X",ret);
-		}
-		SDL_Flip(sdl.surface);
-		break;
-#endif
-	case SCREEN_OVERLAY:
-		SDL_UnlockYUVOverlay(sdl.overlay);
-		SDL_DisplayYUVOverlay(sdl.overlay,&sdl.clip);
-		break;
-#if C_OPENGL
-	case SCREEN_OPENGL:
-		// Clear drawing area. Some drivers (on Linux) have more than 2 buffers and the screen might
-		// be dirty because of other programs.
-		glClearColor (0.0, 0.0, 0.0, 1.0);
-		glClear(GL_COLOR_BUFFER_BIT);
-		if (sdl.opengl.pixel_buffer_object) {
-			glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT);
-			glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
-			glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0,
-					sdl.draw.width, sdl.draw.height, GL_BGRA_EXT,
-					GL_UNSIGNED_INT_8_8_8_8_REV, 0);
-			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
-			glCallList(sdl.opengl.displaylist);
-			SDL_GL_SwapBuffers();
-		} else if (changedLines) {
-			Bitu y = 0, index = 0;
-			glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
-			while (y < sdl.draw.height) {
-				if (!(index & 1)) {
-					y += changedLines[index];
-				} else {
-					Bit8u *pixels = (Bit8u *)sdl.opengl.framebuf + y * sdl.opengl.pitch;
-					Bitu height = changedLines[index];
-					glTexSubImage2D(GL_TEXTURE_2D, 0, 0, y,
-						sdl.draw.width, height, GL_BGRA_EXT,
-						GL_UNSIGNED_INT_8_8_8_8_REV, pixels );
-					y += height;
-				}
-				index++;
-			}
-			glCallList(sdl.opengl.displaylist);
-			SDL_GL_SwapBuffers();
-		}
-		break;
-#endif
-	default:
-		break;
-	}
+	sdl.desktop.screen.EndUpdate( changedLines );
 }
 
-
 void GFX_SetPalette(Bitu start,Bitu count,GFX_PalEntry * entries) {
 	/* I should probably not change the GFX_PalEntry :) */
 	if (sdl.surface->flags & SDL_HWPALETTE) {
@@ -1057,29 +1551,8 @@
 	}
 }
 
-Bitu GFX_GetRGB(Bit8u red,Bit8u green,Bit8u blue) {
-	switch (sdl.desktop.type) {
-	case SCREEN_SURFACE:
-	case SCREEN_SURFACE_DDRAW:
-		return SDL_MapRGB(sdl.surface->format,red,green,blue);
-	case SCREEN_OVERLAY:
-		{
-			Bit8u y =  ( 9797*(red) + 19237*(green) +  3734*(blue) ) >> 15;
-			Bit8u u =  (18492*((blue)-(y)) >> 15) + 128;
-			Bit8u v =  (23372*((red)-(y)) >> 15) + 128;
-#ifdef WORDS_BIGENDIAN
-			return (y << 0) | (v << 8) | (y << 16) | (u << 24);
-#else
-			return (u << 0) | (y << 8) | (v << 16) | (y << 24);
-#endif
-		}
-	case SCREEN_OPENGL:
-//		return ((red << 0) | (green << 8) | (blue << 16)) | (255 << 24);
-		//USE BGRA
-		return ((blue << 0) | (green << 8) | (red << 16)) | (255 << 24);
-	}
-	return 0;
-}
+Bitu GFX_GetRGB(Bit8u red,Bit8u green,Bit8u blue)
+{	return sdl.desktop.screen.GetRgb( red, green, blue );	}
 
 void GFX_Stop() {
 	if (sdl.updating)
@@ -1176,6 +1649,34 @@
 //extern void UI_Run(bool);
 void Restart(bool pressed);
 
+enum ResKind { RES_ORIGINAL, RES_DESKTOP, RES_FIXED };
+
+ResKind ParseRes( char* res, Bit16u* w, Bit16u* h )
+{	char* height = NULL;
+	*w = 0; *h = 0;
+	ResKind kind = RES_ORIGINAL;
+	if( res == NULL || *res == '\0' )
+	{	goto end;  }
+	char res_buf[100];
+	safe_strncpy( res_buf, res, sizeof( res_buf ) );
+	res = lowcase ( res_buf );//so x and X are allowed
+	if( strcmp( res,"original" ) == 0 )
+	{	goto end;  }
+	if( strcmp( res,"desktop" ) == 0 )
+	{	kind = RES_DESKTOP;
+		goto end;
+	}
+	height = const_cast<char*>(strchr(res,'x'));
+	if( height == NULL || *height == '\0' )
+	{	goto end;  }
+	kind    = RES_FIXED;
+	*height = 0;
+	*h   = ( Bit16u )atoi( height + 1 );
+	*w   = ( Bit16u )atoi( res );
+end:
+	return kind;
+}
+
 static void GUI_StartUp(Section * sec) {
 	sec->AddDestroyFunction(&GUI_ShutDown);
 	Section_prop * section=static_cast<Section_prop *>(sec);
@@ -1188,6 +1689,7 @@
 	sdl.desktop.lazy_fullscreen_req=false;
 
 	sdl.desktop.fullscreen=section->Get_bool("fullscreen");
+	sdl.desktop.fullborderless=section->Get_bool("fullborderless");
 	sdl.wait_on_error=section->Get_bool("waitonerror");
 
 	Prop_multival* p=section->Get_multival("priority");
@@ -1216,43 +1718,13 @@
 	sdl.mouse.locked=false;
 	mouselocked=false; //Global for mapper
 	sdl.mouse.requestlock=false;
-	sdl.desktop.full.fixed=false;
-	const char* fullresolution=section->Get_string("fullresolution");
-	sdl.desktop.full.width  = 0;
-	sdl.desktop.full.height = 0;
-	if(fullresolution && *fullresolution) {
-		char res[100];
-		safe_strncpy( res, fullresolution, sizeof( res ));
-		fullresolution = lowcase (res);//so x and X are allowed
-		if (strcmp(fullresolution,"original")) {
-			sdl.desktop.full.fixed = true;
-			if (strcmp(fullresolution,"desktop")) { //desktop = 0x0
-				char* height = const_cast<char*>(strchr(fullresolution,'x'));
-				if (height && * height) {
-					*height = 0;
-					sdl.desktop.full.height = (Bit16u)atoi(height+1);
-					sdl.desktop.full.width  = (Bit16u)atoi(res);
-				}
-			}
-		}
-	}
 
-	sdl.desktop.window.width  = 0;
-	sdl.desktop.window.height = 0;
-	const char* windowresolution=section->Get_string("windowresolution");
-	if(windowresolution && *windowresolution) {
-		char res[100];
-		safe_strncpy( res,windowresolution, sizeof( res ));
-		windowresolution = lowcase (res);//so x and X are allowed
-		if(strcmp(windowresolution,"original")) {
-			char* height = const_cast<char*>(strchr(windowresolution,'x'));
-			if(height && *height) {
-				*height = 0;
-				sdl.desktop.window.height = (Bit16u)atoi(height+1);
-				sdl.desktop.window.width  = (Bit16u)atoi(res);
-			}
-		}
-	}
+	ResKind deskRes = ParseRes
+	(	(char*)section->Get_string("fullresolution"),
+		&sdl.desktop.full.width, &sdl.desktop.full.height
+	);
+	// fix the fullscreen resolution for a borderelss window:
+	sdl.desktop.full.fixed = sdl.desktop.fullborderless || deskRes != RES_ORIGINAL;
 	sdl.desktop.doublebuf=section->Get_bool("fulldouble");
 #if SDL_VERSION_ATLEAST(1, 2, 10)
 #ifdef WIN32
@@ -1294,6 +1766,16 @@
 		sdl.desktop.full.height=768;
 #endif
 	}
+	ResKind windowRes = ParseRes
+	(	(char*)section->Get_string("windowresolution"),
+		&sdl.desktop.window.width, &sdl.desktop.window.height
+	);
+	if( windowRes == RES_DESKTOP )
+	{	// Ant_222: I don't know how else to correct for the window borders:
+		sdl.desktop.window.height = sdl.desktop.full.height - 42;
+		sdl.desktop.window.width  = sdl.desktop.full.width  - 16;
+	}
+
 	sdl.mouse.autoenable=section->Get_bool("autolock");
 	if (!sdl.mouse.autoenable) SDL_ShowCursor(SDL_DISABLE);
 	sdl.mouse.autolock=false;
@@ -1308,6 +1790,20 @@
 
 	if (output == "surface") {
 		sdl.desktop.want_type=SCREEN_SURFACE;
+	} else if (output == "surfacepp") {
+		sdl.desktop.want_type=SCREEN_SURFACE;
+		sdl.SurfaceMode = SM_PERFECT;
+	} else if (output == "surfacenp") {
+		sdl.ps_sharpness=(double)section->Get_int("surfacenp-sharpness") / 100.0;
+		sdl.desktop.want_type=SCREEN_SURFACE;
+		// fallback to nearest-neighbor for better performace:
+		if( sdl.ps_sharpness == 1.0 ) 
+		{	sdl.SurfaceMode = SM_NEIGHBOR;  }
+		else
+		{	sdl.SurfaceMode = SM_SOFT;  }
+	} else if (output == "surfacenb") {
+		sdl.desktop.want_type=SCREEN_SURFACE;
+		sdl.SurfaceMode = SM_NEIGHBOR;
 #if C_DDRAW
 	} else if (output == "ddraw") {
 		sdl.desktop.want_type=SCREEN_SURFACE_DDRAW;
@@ -1317,10 +1813,13 @@
 #if C_OPENGL
 	} else if (output == "opengl") {
 		sdl.desktop.want_type=SCREEN_OPENGL;
-		sdl.opengl.bilinear=true;
+		sdl.opengl.kind = GlkBilinear;
 	} else if (output == "openglnb") {
 		sdl.desktop.want_type=SCREEN_OPENGL;
-		sdl.opengl.bilinear=false;
+		sdl.opengl.kind = GlkNearest;
+	} else if (output == "openglpp") {
+		sdl.desktop.want_type=SCREEN_OPENGL;
+		sdl.opengl.kind = GlkPerfect;
 #endif
 	} else {
 		LOG_MSG("SDL: Unsupported output device %s, switching back to surface",output.c_str());
@@ -1335,6 +1834,7 @@
 		LOG_MSG("Could not initialize OpenGL, switching back to surface");
 		sdl.desktop.want_type=SCREEN_SURFACE;
 	} else {
+	sdl.opengl.vsync = section->Get_bool("glfullvsync");
 	sdl.opengl.buffer=0;
 	sdl.opengl.framebuf=0;
 	sdl.opengl.texture=0;
@@ -1736,10 +2236,13 @@
 	Pbool = sdl_sec->Add_bool("fullscreen",Property::Changeable::Always,false);
 	Pbool->Set_help("Start dosbox directly in fullscreen. (Press ALT-Enter to go back)");
 
+	Pbool = sdl_sec->Add_bool("fullborderless",Property::Changeable::Always,false);
+	Pbool->Set_help("Emulate fullscreen as a borderless window");
+
 	Pbool = sdl_sec->Add_bool("fulldouble",Property::Changeable::Always,false);
 	Pbool->Set_help("Use double buffering in fullscreen. It can reduce screen flickering, but it can also result in a slow DOSBox.");
 
-	Pstring = sdl_sec->Add_string("fullresolution",Property::Changeable::Always,"original");
+	Pstring = sdl_sec->Add_string("fullresolution",Property::Changeable::Always,"desktop");
 	Pstring->Set_help("What resolution to use for fullscreen: original, desktop or a fixed size (e.g. 1024x768).\n"
 	                  "Using your monitor's native resolution with aspect=true might give the best results.\n"
 			  "If you end up with small window on a large screen, try an output different from surface."
@@ -1746,22 +2249,47 @@
 	                  "On Windows 10 with display scaling (Scale and layout) set to a value above 100%, it is recommended\n"
 	                  "to use a lower full/windowresolution, in order to avoid window size problems.");
 
-	Pstring = sdl_sec->Add_string("windowresolution",Property::Changeable::Always,"original");
+	Pstring = sdl_sec->Add_string("windowresolution",Property::Changeable::Always,"desktop");
 	Pstring->Set_help("Scale the window to this size IF the output device supports hardware scaling.\n"
 	                  "(output=surface does not!)");
 
 	const char* outputs[] = {
-		"surface", "overlay",
+		"surface", "surfacepp", "surfacenp", "surfacenb", "overlay",
 #if C_OPENGL
-		"opengl", "openglnb",
+		"opengl", "openglnb", "openglpp",
 #endif
 #if C_DDRAW
 		"ddraw",
 #endif
-		0 };
-	Pstring = sdl_sec->Add_string("output",Property::Changeable::Always,"surface");
-	Pstring->Set_help("What video system to use for output.");
+		0
+	};
+	Pstring = sdl_sec->Add_string("output",Property::Changeable::Always,
+#if C_OPENGL
+	"openglpp"
+#else
+	"surfacepp"
+#endif
+	);
+	Pstring->Set_help
+	(	"What video system to use for output.\n"
+		"Some values are aliases for output-scaler combinations:\n"
+		"  surfacepp and openglpp -- pixel-perfect scaling;\n"
+		"  surfacenp -- near-perfect scaling via bilinear interpolation;\n"
+		"  surfacenb and openglnb -- nearest-neighbor scaling."
+	);
+	Pint = sdl_sec->Add_int("surfacenp-sharpness",Property::Changeable::Always,50);
+	Pint->SetMinMax(0, 100);
+	Pint->Set_help
+	(	"Sharpness for the 'surfacenp' output type,\n"
+		"Measured in percent."
+	);
+
 	Pstring->Set_values(outputs);
+	
+#if C_OPENGL
+	Pbool = sdl_sec->Add_bool("glfullvsync",Property::Changeable::Always,false);
+	Pbool->Set_help("Activate V-Sync for OpenGL in fullscreen.");
+#endif
 
 	Pbool = sdl_sec->Add_bool("autolock",Property::Changeable::Always,true);
 	Pbool->Set_help("Mouse will automatically lock, if you click on the screen. (Press CTRL-F10 to unlock)");
