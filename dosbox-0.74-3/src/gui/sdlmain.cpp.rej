diff a/dosbox-0.74-3/src/gui/sdlmain.cpp b/dosbox-0.74-3/src/gui/sdlmain.cpp	(rejected hunks)
@@ -167,11 +206,12 @@
 		} window;
 		Bit8u bpp;
 		bool fullscreen;
+		bool fullborderless;
 		bool lazy_fullscreen;
 		bool lazy_fullscreen_req;
 		bool doublebuf;
-		SCREEN_TYPES type;
 		SCREEN_TYPES want_type;
+		ScreenTypeInfo screen;
 	} desktop;
 #if C_OPENGL
 	struct {
@@ -209,7 +250,15 @@
 		int xsensitivity;
 		int ysensitivity;
 	} mouse;
+	SURFACE_MODE SurfaceMode;
+	SurfaceModeInfo SurfaceInfo;
+	double    ps_sharpness;
+	ps_pixels ps_buffer;
+	ps_info   pixel_scaling;
+	char      dbl_h, dbl_w;
+	double    ps_scale_x, ps_scale_y;
 	SDL_Rect updateRects[1024];
+	unsigned rectCount;
 	Bitu num_joysticks;
 #if defined (WIN32)
 	bool using_windib;
@@ -368,71 +432,879 @@
 }
 #endif
 
-/* Reset the screen with current values in the sdl structure */
-Bitu GFX_GetBestMode(Bitu flags) {
-	Bitu testbpp,gotbpp;
-	switch (sdl.desktop.want_type) {
-	case SCREEN_SURFACE:
-check_surface:
-		flags &= ~GFX_LOVE_8;		//Disable love for 8bpp modes
-		/* Check if we can satisfy the depth it loves */
-		if (flags & GFX_LOVE_8) testbpp=8;
-		else if (flags & GFX_LOVE_15) testbpp=15;
-		else if (flags & GFX_LOVE_16) testbpp=16;
-		else if (flags & GFX_LOVE_32) testbpp=32;
-		else testbpp=0;
-#if C_DDRAW
-check_gotbpp:
-#endif
-		if (sdl.desktop.fullscreen) gotbpp=SDL_VideoModeOK(640,480,testbpp,SDL_FULLSCREEN|SDL_HWSURFACE|SDL_HWPALETTE);
-		else gotbpp=sdl.desktop.bpp;
-		/* If we can't get our favorite mode check for another working one */
-		switch (gotbpp) {
-		case 8:
-			if (flags & GFX_CAN_8) flags&=~(GFX_CAN_15|GFX_CAN_16|GFX_CAN_32);
+static int int_log2 (int val) {
+    int log = 0;
+    while ((val >>= 1) != 0)
+	log++;
+    return log;
+}
+
+static SDL_Surface * GFX_SetupSurfaceScaled(Bitu flags, Bit32u sdl_flags, Bit32u bpp); // Forward decl.
+
+void CheckGotBpp( Bitu *flags, Bitu testbpp )
+{	Bitu gotbpp;
+	if (sdl.desktop.fullscreen)
+	{	gotbpp=SDL_VideoModeOK(640,480,testbpp,SDL_FULLSCREEN|SDL_HWSURFACE|SDL_HWPALETTE); }
+	else
+	{	gotbpp=sdl.desktop.bpp;  }
+	/* If we can't get our favorite mode check for another working one */
+	switch (gotbpp)
+	{	case 8:
+			if (*flags & GFX_CAN_8) *flags&=~(GFX_CAN_15|GFX_CAN_16|GFX_CAN_32);
 			break;
 		case 15:
-			if (flags & GFX_CAN_15) flags&=~(GFX_CAN_8|GFX_CAN_16|GFX_CAN_32);
+			if (*flags & GFX_CAN_15) *flags&=~(GFX_CAN_8|GFX_CAN_16|GFX_CAN_32);
 			break;
 		case 16:
-			if (flags & GFX_CAN_16) flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_32);
+			if (*flags & GFX_CAN_16) *flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_32);
 			break;
 		case 24:
 		case 32:
-			if (flags & GFX_CAN_32) flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
+			if (*flags & GFX_CAN_32) *flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
 			break;
+	}
+	*flags |= GFX_CAN_RANDOM;
+}
+
+Bitu CheckSurface( Bitu *flags )
+{	Bitu testbpp;
+	*flags &= ~GFX_LOVE_8;		//Disable love for 8bpp modes
+	/* Check if we can satisfy the depth it loves */
+	if (*flags & GFX_LOVE_8) testbpp=8;
+	else if (*flags & GFX_LOVE_15) testbpp=15;
+	else if (*flags & GFX_LOVE_16) testbpp=16;
+	else if (*flags & GFX_LOVE_32) testbpp=32;
+	else testbpp=0;
+	return testbpp;
+}
+
+void GetChangedLines( const Bit16u *changedLines )
+{	sdl.rectCount = 0; // if need be, declare it as a local variable and fill the parameter at the end.
+	if ( !changedLines )
+	{	return;  }
+
+	Bitu y = 0, index = 0;
+	while (y < sdl.draw.height)
+	{	if ( index & 1 )
+		{	SDL_Rect *rect = &sdl.updateRects[ sdl.rectCount++ ];
+			rect->x = 0;
+			rect->y = y;
+			rect->w = (Bit16u)sdl.draw.width;
+			rect->h = changedLines[index];
+#if 0
+			if (rect->h + rect->y > sdl.surface->h) {
+				LOG_MSG("WTF %d +  %d  >%d",rect->h,rect->y,sdl.surface->h);
+			}
+#endif
 		}
-		flags |= GFX_CAN_RANDOM;
+		y += changedLines[index];
+		index++;
+	}
+}
+
+static void GetAvailableArea( Bit16u *width, Bit16u *height, bool *fixed )
+{	*fixed = false;
+	if( sdl.desktop.fullscreen )
+	{	if( sdl.desktop.full.fixed )
+		{	*width  = sdl.desktop.full.width;
+			*height = sdl.desktop.full.height;
+			*fixed  = true;
+		}
+	}
+	else
+	{	if( sdl.desktop.window.width > 0 )
+		{	*width  = sdl.desktop.window.width;
+			*height = sdl.desktop.window.height;
+			*fixed  = true;
+		}
+	}
+}
+
+// ATT: aspect is the final aspect ratio of the image including its pixel dimensions and PAR
+static void GetActualArea( Bit16u av_w, Bit16u av_h, Bit16u *w, Bit16u *h, double aspect )
+{	double as_x, as_y;
+	if( aspect > 1.0 )
+	{	as_y = aspect  ; as_x = 1.0;  }
+	else
+	{	as_x = 1.0/aspect; as_y = 1.0;  }
+	if( av_h / as_y < av_w / as_x )
+	{	*h = av_h; *w = round( (double)av_h / aspect );  }
+	else
+	{	*w = av_w; *h = round( (double)av_w * aspect );  }
+}
+
+static Bit32u genflags( Bitu flags )
+{	Bit32u res;
+	res = 0;
+	if( sdl.desktop.fullscreen )
+	{	if( sdl.desktop.fullborderless )
+		{	res |= SDL_NOFRAME;
+			SDL_putenv("SDL_VIDEO_WINDOW_POS=center");
+		}
+		else
+		{	res |= SDL_FULLSCREEN;
+			if( sdl.desktop.doublebuf ) res |= SDL_DOUBLEBUF;
+		}
+	}
+	if( flags & GFX_CAN_RANDOM ) res |= SDL_SWSURFACE;
+	else                         res |= SDL_HWSURFACE;
+	return res;
+}
+
+/* ----------------- Operations depending on SCREEN_TYPES ----------------- */
+/* ----------------- Possibly move them to a separate unit ---------------- */
+
+ps_format rgb_32_fmt_in    = { 0, 4 };
+ps_format rgb_32_fmt_out   = { 0, 4 };
+
+void ssSmInit(Bit16u w_in, Bit16u h_in, Bit16u *w_out, Bit16u *h_out, int* bpp )
+{	*w_out = w_in;
+	*h_out = h_in;
+}
+
+ps_pixels ps_create_buffer( ps_size size )
+{	ps_pixels buf;
+	buf.pixels = (unsigned char*)calloc( 4, size.w * size.h );
+	buf.pitch  = size.w * 4;
+	return buf;
+}
+
+/* We must know the pixel layout before calling ps_new_*()                  */
+/* As a temporary solution, I (Ant_222) am reading it from the current mode */
+/* TODO: Rewrite the scaler so as to separate the calculation of the output */
+/*       dimensions from the initialization of the scaling structure. then  */
+/*       analyse the layout of the actual surface.                          */ 
+static void PsInitFormats( void )
+{	unsigned char offs;
+	const SDL_VideoInfo * i;
+	i = SDL_GetVideoInfo();
+	if( i->vfmt->Rshift > 0 && i->vfmt->Bshift > 0 )
+	{	offs = 1;  }
+	else
+	{	offs = 0;  }
+	rgb_32_fmt_in .offs = offs;
+	rgb_32_fmt_out.offs = offs;
+}
+
+/* TODO: these ~Init() functons are too repetitive, therefore generalize them */
+/*       via some common interface, e.g.: GetOutputSize, InitScaling:         */
+void ssPpInit(Bit16u w_in, Bit16u h_in, Bit16u *w_out, Bit16u *h_out, int* bpp )
+{	*bpp = 32;
+	ps_size size_in, size_out, size_res;
+	PsInitFormats();
+	size_in .w =  w_in ; size_in .h =  h_in;
+	size_out.w = *w_out; size_out.h = *h_out;
+	sdl.pixel_scaling = ps_new_perfect
+	(	rgb_32_fmt_in,   size_in,
+		rgb_32_fmt_out,  size_out,
+		sdl.dbl_w,       sdl.dbl_h, 3,
+		sdl.draw.aspect, &size_res
+	);
+	*h_out = size_res.h;
+	*w_out = size_res.w;
+	sdl.ps_buffer = ps_create_buffer( size_in );
+}
+
+void ssNpInit(Bit16u w_in, Bit16u h_in, Bit16u *w_out, Bit16u *h_out, int* bpp )
+{	*bpp = 32;
+	ps_size size_in, size_out;
+	PsInitFormats();
+	GetActualArea( *w_out, *h_out, w_out, h_out, sdl.draw.aspect * sdl.draw.height / sdl.draw.width );
+	size_in .w =  w_in ; size_in .h =  h_in;
+	size_out.w = *w_out; size_out.h = *h_out;
+	sdl.ps_buffer = ps_create_buffer( size_in );
+	sdl.pixel_scaling = ps_new_soft
+	(	rgb_32_fmt_in,  size_in,
+		rgb_32_fmt_out, size_out,
+		sdl.dbl_w,      sdl.dbl_h, 3,
+		(double)1.0-sdl.ps_sharpness
+	);
+}
+
+void ssNbInit(Bit16u w_in, Bit16u h_in, Bit16u *w_out, Bit16u *h_out, int* bpp )
+{	*bpp = 32;
+	ps_size size_in, size_out;
+	PsInitFormats();
+	GetActualArea( *w_out, *h_out, w_out, h_out, sdl.draw.aspect * sdl.draw.height / sdl.draw.width );
+	size_in .w =  w_in ; size_in .h =  h_in;
+	size_out.w = *w_out; size_out.h = *h_out;
+	sdl.ps_buffer = ps_create_buffer( size_in );
+	sdl.pixel_scaling = ps_new_nn
+	(	rgb_32_fmt_in,  size_in,
+		rgb_32_fmt_out, size_out,
+		sdl.dbl_w, sdl.dbl_h, 3
+	);
+}
+
+char ssGetOutPixels( Bit8u **pixels, Bitu *pitch )
+{	if( sdl.blit.surface != NULL )
+	{	if (SDL_MUSTLOCK(sdl.blit.surface) && SDL_LockSurface(sdl.blit.surface))
+			return 0;
+		*pixels=(Bit8u *)sdl.blit.surface->pixels;
+		*pitch=sdl.blit.surface->pitch;
+	}
+	else
+	{	if (SDL_MUSTLOCK(sdl.surface) && SDL_LockSurface(sdl.surface))
+			return 0;
+		*pixels=(Bit8u *)sdl.surface->pixels;
+		*pixels+=sdl.clip.y*sdl.surface->pitch;
+		*pixels+=sdl.clip.x*sdl.surface->format->BytesPerPixel;
+
+		*pitch=sdl.surface->pitch;
+	}
+	return 1;
+}
+
+char ssSmStartUpdate( Bit8u **pixels, Bitu *pitch )
+{	ssGetOutPixels( pixels, pitch );
+	return 1;
+}
+
+char ssPsStartUpdate( Bit8u **pixels, Bitu *pitch )
+{	*pixels = sdl.ps_buffer.pixels;
+	*pitch  = sdl.ps_buffer.pitch;
+	return 1;
+}
+
+void ssImageToScreen()
+{	if( sdl.blit.surface )
+	{	if( SDL_MUSTLOCK( sdl.blit.surface ) )
+			SDL_UnlockSurface(sdl.blit.surface);
+		SDL_BlitSurface( sdl.blit.surface, 0, sdl.surface, &sdl.clip );
+		SDL_Flip( sdl.surface );
+	}
+	else
+	{	if( SDL_MUSTLOCK( sdl.surface ) ) SDL_UnlockSurface(sdl.surface);
+		for( int i = 0; i < sdl.rectCount; i++ )
+		{	sdl.updateRects[i].x += sdl.clip.x;
+			sdl.updateRects[i].y += sdl.clip.y;
+		}
+		SDL_UpdateRects( sdl.surface, sdl.rectCount, sdl.updateRects );
+	}
+}
+
+void ssSmEndUpdate()
+{  }
+
+static void rect_sdl_to_ps( SDL_Rect const rect_sdl, ps_rect* rect_ps )
+{	rect_ps->x = rect_sdl.x;
+	rect_ps->y = rect_sdl.y;
+	rect_ps->w = rect_sdl.w;
+	rect_ps->h = rect_sdl.h;
+}
+
+static void rect_ps_to_sdl( ps_rect const rect_ps, SDL_Rect* rect_sdl )
+{	rect_sdl->x = rect_ps.x;
+	rect_sdl->y = rect_ps.y;
+	rect_sdl->h = rect_ps.h;
+	rect_sdl->w = rect_ps.w; 
+}
+
+void ssPsEndUpdate()
+{	int i;
+	Bitu pitch_bitu; // for type compatibility
+	ps_pixels pix_out;
+	ps_rect rect;
+	SDL_PixelFormat* format;
+
+	ssGetOutPixels( &pix_out.pixels, &pitch_bitu );
+	pix_out.pitch = pitch_bitu;
+	for( int i = 0; i < sdl.rectCount; i++ )
+	{	rect_sdl_to_ps( sdl.updateRects[i], &rect ); 
+		ps_scale( sdl.pixel_scaling, sdl.ps_buffer, pix_out, &rect );
+		rect_ps_to_sdl( rect, &sdl.updateRects[i] );
+	}
+}
+
+SurfaceModeInfo ssModes[4] =
+{	{ ssSmInit, ssSmStartUpdate, ssSmEndUpdate },
+	{ ssPpInit, ssPsStartUpdate, ssPsEndUpdate },
+	{ ssNpInit, ssPsStartUpdate, ssPsEndUpdate },
+	{ ssNbInit, ssPsStartUpdate, ssPsEndUpdate }
+};
+
+void ssSetSurfaceMode( SURFACE_MODE mode )
+{	sdl.SurfaceInfo = ssModes[ mode ];  }
+
+// TODO: Unity scale should be set later, when we are cetain that the resolution
+//       not the windowed-original
+Bitu ssBestMode( Bitu *flags )
+{	Bitu cs_res = CheckSurface( flags );
+	if( sdl.SurfaceMode != SM_SIMPLE )
+	{	*flags |= GFX_UNITY_SCALE;  }
+	return cs_res;
+}
+
+char ssSetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley, Bitu *retFlags)
+{	bool fixed;
+	Bit16u av_h, av_w, out_w, out_h;
+	int bpp;
+	SURFACE_MODE sm;
+	
+	if( sdl.pixel_scaling != NULL )
+	{	ps_free( sdl.pixel_scaling );
+		sdl.pixel_scaling = NULL;
+		free( sdl.ps_buffer.pixels );
+	}
+	av_w = width; av_h = height;
+	GetAvailableArea( &av_w, &av_h, &fixed );
+	if( !fixed && !sdl.desktop.fullscreen )
+	{	if( sdl.draw.aspect > 1.0 )
+		{	av_h *= sdl.draw.aspect;  }
+		if( sdl.draw.aspect < 1.0 )
+		{	av_w /= sdl.draw.aspect;  }
+	}
+	LOG_MSG("Available area: %ix%i", av_w, av_h);
+	ssSetSurfaceMode( sdl.SurfaceMode );
+
+	bpp = 0;
+	if (flags & GFX_CAN_8)  bpp= 8;
+	if (flags & GFX_CAN_15) bpp=15;
+	if (flags & GFX_CAN_16) bpp=16;
+	if (flags & GFX_CAN_32) bpp=32;
+
+	out_w = av_w; out_h = av_h;
+	sdl.SurfaceInfo.Init( width, height, &out_w, &out_h, &bpp );
+
+	sdl.ps_scale_x = ( double )out_w / width;
+	sdl.ps_scale_y = ( double )out_h / height;
+	char s[80];
+	LOG_MSG
+	(	"Scaling: %ix%i (%4.2f) --[%3.1f x %3.1f]--> %4ix%-4i (%4.2f)",
+		width, height, sdl.draw.aspect,
+		sdl.ps_scale_x, sdl.ps_scale_y,
+		out_w, out_h, sdl.ps_scale_y / sdl.ps_scale_x
+	);
+
+	Bit32u sfcflags = genflags( flags );
+	sdl.clip.w=out_w;
+	sdl.clip.h=out_h;
+	if (sdl.desktop.fullscreen) {
+		sfcflags |= SDL_HWPALETTE;
+		if (sdl.desktop.full.fixed) {
+			sdl.clip.x=(Sint16)((sdl.desktop.full.width -out_w)/2);
+			sdl.clip.y=(Sint16)((sdl.desktop.full.height-out_h)/2);
+			sdl.surface=SDL_SetVideoMode_Wrap(sdl.desktop.full.width,
+				sdl.desktop.full.height,bpp,sfcflags);
+
+			if (sdl.surface == NULL) E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",sdl.desktop.full.width,sdl.desktop.full.height,bpp,SDL_GetError());
+		} else {
+			sdl.clip.x=0;sdl.clip.y=0;
+			sdl.surface=SDL_SetVideoMode_Wrap(out_w,out_h,bpp,sfcflags);
+
+			if (sdl.surface == NULL)
+				E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",(int)width,(int)height,bpp,SDL_GetError());
+		}
+	} else {
+		sdl.clip.x=0;sdl.clip.y=0;
+		sdl.surface=SDL_SetVideoMode_Wrap(out_w,out_h,bpp, sfcflags);
+#ifdef WIN32
+		if (sdl.surface == NULL) {
+			SDL_QuitSubSystem(SDL_INIT_VIDEO);
+			if (!sdl.using_windib) {
+				LOG_MSG("Failed to create hardware surface.\nRestarting video subsystem with windib enabled.");
+				putenv("SDL_VIDEODRIVER=windib");
+				sdl.using_windib=true;
+			} else {
+				LOG_MSG("Failed to create hardware surface.\nRestarting video subsystem with directx enabled.");
+				putenv("SDL_VIDEODRIVER=directx");
+				sdl.using_windib=false;
+			}
+			SDL_InitSubSystem(SDL_INIT_VIDEO);
+			GFX_SetIcon(); //Set Icon again
+			sdl.surface = SDL_SetVideoMode_Wrap(out_w,out_h,bpp,SDL_HWSURFACE);
+			if(sdl.surface) GFX_SetTitle(-1,-1,false); //refresh title.
+		}
+#endif
+		if (sdl.surface == NULL)
+			E_Exit("Could not set windowed video mode %ix%i-%i: %s",(int)width,(int)height,bpp,SDL_GetError());
+	}
+	if (sdl.surface) {
+		switch (sdl.surface->format->BitsPerPixel) {
+		case 8:
+			*retFlags = GFX_CAN_8;
+				 break;
+		case 15:
+			*retFlags = GFX_CAN_15;
+			break;
+		case 16:
+			*retFlags = GFX_CAN_16;
+				 break;
+		case 32:
+			*retFlags = GFX_CAN_32;
+				 break;
+		}
+		if (*retFlags && (sdl.surface->flags & SDL_HWSURFACE))
+			*retFlags |= GFX_HARDWARE;
+		if (*retFlags && (sdl.surface->flags & SDL_DOUBLEBUF)) {
+		//if( 1==1 ) { //force blit surface for debuggin
+			sdl.blit.surface=SDL_CreateRGBSurface(SDL_HWSURFACE,
+				sdl.clip.w, sdl.clip.h,
+				sdl.surface->format->BitsPerPixel,
+				sdl.surface->format->Rmask,
+				sdl.surface->format->Gmask,
+				sdl.surface->format->Bmask,
+			0);
+			/* If this one fails be ready for some flickering... */
+		}
+	}
+	SDL_Rect rect;
+	rect.x = 0; rect.y = 0; rect.w = sdl.surface->w; rect.h = sdl.surface->h;
+	return 1; // Success
+}
+
+
+char ssStartUpdate( Bit8u **pixels, Bitu *pitch )
+{	return sdl.SurfaceInfo.StartUpdate( pixels, pitch );  }
+
+void ssEndUpdate( const Bit16u *changedLines )
+{	GetChangedLines( changedLines );
+	sdl.SurfaceInfo.EndUpdate(); // Output processed image if using buffer and scale the rectangles.
+	ssImageToScreen();
+}
+
+// Rectangles must already be calculated and if necessary--scaled.
+Bitu ssGetRgb( Bit8u red, Bit8u green, Bit8u blue )
+{	return SDL_MapRGB(sdl.surface->format,red,green,blue);  }
+
+Bitu soBestMode( Bitu *flags )
+{	Bitu testbpp;
+
+	//We only accept 32bit output from the scalers here
+	//Can't handle true color inputs
+	if( *flags & GFX_RGBONLY || !( *flags & GFX_CAN_32 ) )
+	{	testbpp = CheckSurface( flags );  }
+	else
+	{	*flags|=GFX_SCALING;
+		*flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
+		testbpp = 0;
+	}
+	return testbpp;
+}
+
+char soSetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley, Bitu *retFlags){	if (sdl.overlay) {
+		SDL_FreeYUVOverlay(sdl.overlay);
+		sdl.overlay=0;
+	}
+
+	if (!(flags&GFX_CAN_32) || (flags & GFX_RGBONLY)) return 0;
+	if (!GFX_SetupSurfaceScaled(flags, 0,0)) return 0;
+
+	int width_out  = 2 * width;
+	int height_out =     height;
+	sdl.overlay=SDL_CreateYUVOverlay(width_out,height_out,SDL_UYVY_OVERLAY,sdl.surface);
+	if (!sdl.overlay) {
+		LOG_MSG("SDL:Failed to create overlay, switching back to surface");
+		return 0;
+	}
+	
+	SDL_LockYUVOverlay( sdl.overlay );
+	char* cursor = (char*)sdl.overlay->pixels[0];
+	// TODO: Handle margins in sdl.clip and remove this:
+	for( long i = 0; i < sdl.overlay->pitches[0]/4*sdl.overlay->h; i++ ) // This is a one time procedure, so it needs no optimization.
+	{	*cursor++ = 128;
+		*cursor++ = 0;
+		*cursor++ = 128;
+		*cursor++ = 0;
+	}
+	SDL_UnlockYUVOverlay( sdl.overlay );
+	if( SDL_MUSTLOCK( sdl.surface ) )
+	{	SDL_LockSurface( sdl.surface );  }
+	int scanLen = sdl.surface->pitch;
+	cursor = (char*)sdl.surface->pixels;
+	for( int i = 0; i < sdl.surface->h; i++ )
+	{	for( int x = 0; x < scanLen; x++ )
+		{	*cursor++ = 0;  }
+	}
+	if( SDL_MUSTLOCK( sdl.surface ) )
+	{	SDL_UnlockSurface( sdl.surface );  }
+	*retFlags = GFX_CAN_32 | GFX_SCALING | GFX_HARDWARE;
+	return 1;
+}
+
+char soStartUpdate( Bit8u **pixels, Bitu *pitch )
+{	while( 1==1 ) //HACK: No idea why several attempts may be required. People at #SDL couldn't help
+	{	if (SDL_LockYUVOverlay(sdl.overlay))
+		{	continue;  }
 		break;
+	}
+	if (SDL_MUSTLOCK( sdl.surface ) )
+	{	if( SDL_LockSurface( sdl.surface ) )
+		{	return 0; }
+	}
+	*pixels = sdl.overlay->pixels [0];
+	*pitch  = sdl.overlay->pitches[0];
+	return 1;
+}
+
+void soApplyOverlay( SDL_Overlay *overlay )
+{	SDL_UnlockYUVOverlay(overlay);
+	if( SDL_MUSTLOCK( sdl.surface ) )
+	{	SDL_UnlockSurface(sdl.surface);  }
+	SDL_DisplayYUVOverlay(overlay,&sdl.clip);
+}
+
+void soEndUpdate( const Bit16u *changedLines )
+{	soApplyOverlay( sdl.overlay );  }
+
+Bitu soGetRgb( Bit8u red, Bit8u green, Bit8u blue )
+{	Bit8u y =  ( 9797*(red) + 19237*(green) +  3734*(blue) ) >> 15;
+	Bit8u u =  (18492*((blue)-(y)) >> 15) + 128;
+	Bit8u v =  (23372*((red)-(y)) >> 15) + 128;
+#ifdef WORDS_BIGENDIAN
+	return (y << 0) | (v << 8) | (y << 16) | (u << 24);
+#else
+	return (u << 0) | (y << 8) | (v << 16) | (y << 24);
+#endif
+}
+
+Bitu ogBestMode( Bitu *flags )
+{	Bitu testbpp;
+	//We only accept 32bit output from the scalers here
+	if( !( *flags & GFX_CAN_32 ) ) 
+	{	testbpp = CheckSurface( flags );  }
+	else
+	{	*flags|=GFX_SCALING;
+		*flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
+		testbpp = 0;
+	}
+	if( sdl.opengl.kind == GlkPerfect )
+	{	*flags |= GFX_UNITY_SCALE;  }
+	return testbpp;
+}
+
+static void setvsync( bool on )
+{	const char * state;
+	int res;
+	if( on ) state = "on";
+	else     state = "off";
+#if SDL_VERSION_ATLEAST(1,3,0)
+	if( on )
+	{						res = SDL_GL_SetSwapInterval(-1);
+		if( res != 0 ) res = SDL_GL_SetSwapInterval( 1);
+	}
+	else res = SDL_GL_SetSwapInterval( 0 );
+#else
+#if SDL_VERSION_ATLEAST(1,2,11)
+	res = SDL_GL_SetAttribute( SDL_GL_SWAP_CONTROL, on );
+#else
+	if( on )
+		LOG_MSG("...V-Sync not supported in this version of SDL.");
+#define SDL_NOVSYNC
+#endif
+#endif
+#ifndef SDL_NOVSYNC
+	if( res == 0 ) LOG_MSG("V-Sync turned %s.", state); else
+	               LOG_MSG("Failed to turn V-Sync %s: %s", state, SDL_GetError());
+#endif
+}
+
+char ogSetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley, Bitu *retFlags) {
+	if (sdl.opengl.pixel_buffer_object) {
+		glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
+		if (sdl.opengl.buffer) glDeleteBuffersARB(1, &sdl.opengl.buffer);
+	} else if (sdl.opengl.framebuf) {
+		free(sdl.opengl.framebuf);
+	}
+	sdl.opengl.framebuf=0;
+	if( !( flags & GFX_CAN_32 ) ) return 0;
+	int texsize=2 << int_log2(width > height ? width : height);
+	if (texsize>sdl.opengl.max_texsize) {
+		LOG_MSG("SDL:OPENGL:No support for texturesize of %d, falling back to surface",texsize);
+		return 0;
+	}
+	SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
+	setvsync( sdl.opengl.vsync && sdl.desktop.fullscreen && !sdl.desktop.fullborderless );
+	if( sdl.opengl.kind == GlkPerfect )
+	{	Bit16u avh, avw, w, h;
+		bool fixed;
+		ps_size szin, szout, szres;
+		ps_info ps;
+		avw = width; avh = height;
+		GetAvailableArea( &avw, &avh, &fixed );
+		szin .w = width; szin .h = height;
+		szout.w = avw;   szout.h = avh;
+		LOG_MSG("Available area: %ix%i", avw, avh);
+		ps = ps_new_perfect
+		(	rgb_32_fmt_in,   szin,
+			rgb_32_fmt_out,  szout,
+			sdl.dbl_w,       sdl.dbl_h, 3,
+			sdl.draw.aspect, &szres
+		);
+		ps_free( ps );
+		double scalex = (double)szres.w/szin.w;
+		double scaley = (double)szres.h/szin.h;
+		LOG_MSG
+		(	"Scaling: %ix%i (%4.2f) --[%3.1f x %3.1f]--> %4ix%-4i (%4.2f)",
+			szin.w, szin.h, sdl.draw.aspect, scalex, scaley, szres.w, szres.h, scaley/scalex
+		);
+		Bit32u sdl_flags = genflags(flags) | SDL_OPENGL;
+		sdl.clip.x = 0; sdl.clip.y = 0;
+		if( sdl.desktop.fullscreen )
+		{	sdl.clip.w = szres.w; sdl.clip.h = szres.h;
+			w = avw; h = avh;
+		}
+		else
+		{	sdl.clip.w = szres.w; sdl.clip.h = szres.h;
+			w          = szres.w; h          = szres.h;
+		}
+		sdl.surface = SDL_SetVideoMode_Wrap( w, h, 0, sdl_flags);
+	}
+	else GFX_SetupSurfaceScaled(flags, SDL_OPENGL,0);
+	if (!sdl.surface || sdl.surface->format->BitsPerPixel<15) {
+		LOG_MSG("SDL:OPENGL:Can't open drawing surface, are you running in 16bpp(or higher) mode?");
+		return 0;
+	}
+
+	/* Create the texture and display list */
+	if (sdl.opengl.pixel_buffer_object) {
+		glGenBuffersARB(1, &sdl.opengl.buffer);
+		glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, sdl.opengl.buffer);
+		glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_EXT, width*height*4, NULL, GL_STREAM_DRAW_ARB);
+		glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
+	} else {
+		sdl.opengl.framebuf=malloc(width*height*4);		//32 bit color
+	}
+	sdl.opengl.pitch=width*4;
+	if
+	(	sdl.clip.x == 0 && sdl.clip.y == 0 &&
+		(	sdl.clip.w != sdl.surface->w || sdl.clip.h != sdl.surface->h)
+	)
+	{	LOG_MSG("attempting to fix the centering to %d %d %d %d",(sdl.surface->w-sdl.clip.w)/2,(sdl.surface->h-sdl.clip.h)/2,sdl.clip.w,sdl.clip.h);
+		glViewport((sdl.surface->w-sdl.clip.w)/2,(sdl.surface->h-sdl.clip.h)/2,sdl.clip.w,sdl.clip.h);
+	}
+	else
+	{	glViewport(sdl.clip.x,sdl.clip.y,sdl.clip.w,sdl.clip.h);  }		
+
+	glMatrixMode (GL_PROJECTION);
+	glDeleteTextures(1,&sdl.opengl.texture);
+	glGenTextures(1,&sdl.opengl.texture);
+	glBindTexture(GL_TEXTURE_2D,sdl.opengl.texture);
+	// No borders
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+	if (!sdl.opengl.kind == GlkBilinear || ( (sdl.clip.h % height) == 0 && (sdl.clip.w % width) == 0) ) {
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+	} else {
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+	}
+
+	Bit8u* emptytex = new Bit8u[texsize * texsize * 4];
+	memset((void*) emptytex, 0, texsize * texsize * 4);
+	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, texsize, texsize, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, (const GLvoid*)emptytex);
+	delete [] emptytex;
+
+	//glClearColor (0.0, 0.0, 0.0, 1.0);
+	//glClear(GL_COLOR_BUFFER_BIT);
+	//SDL_GL_SwapBuffers();
+	//glClear(GL_COLOR_BUFFER_BIT);
+	glShadeModel (GL_FLAT);
+	glDisable (GL_DEPTH_TEST);
+	glDisable (GL_LIGHTING);
+	glDisable(GL_CULL_FACE);
+	glEnable(GL_TEXTURE_2D);
+	glMatrixMode (GL_MODELVIEW);
+	glLoadIdentity ();
+
+	GLfloat tex_width=((GLfloat)(width)/(GLfloat)texsize);
+	GLfloat tex_height=((GLfloat)(height)/(GLfloat)texsize);
+
+	if (glIsList(sdl.opengl.displaylist)) glDeleteLists(sdl.opengl.displaylist, 1);
+	sdl.opengl.displaylist = glGenLists(1);
+	glNewList(sdl.opengl.displaylist, GL_COMPILE);
+	glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
+	glBegin(GL_QUADS);
+	// lower left
+	glTexCoord2f(0,tex_height); glVertex2f(-1.0f,-1.0f);
+	// lower right
+	glTexCoord2f(tex_width,tex_height); glVertex2f(1.0f, -1.0f);
+	// upper right
+	glTexCoord2f(tex_width,0); glVertex2f(1.0f, 1.0f);
+	// upper left
+	glTexCoord2f(0,0); glVertex2f(-1.0f, 1.0f);
+	glEnd();
+	glEndList();
+	*retFlags = GFX_CAN_32 | GFX_SCALING;
+	if (sdl.opengl.pixel_buffer_object)
+		*retFlags |= GFX_HARDWARE;
+	return 1;
+}
+
+char ogStartUpdate( Bit8u **pixels, Bitu *pitch )
+{	if(sdl.opengl.pixel_buffer_object) {
+		 glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, sdl.opengl.buffer);
+		 *pixels=(Bit8u *)glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, GL_WRITE_ONLY);
+	} else
+		 *pixels=(Bit8u *)sdl.opengl.framebuf;
+	*pitch=sdl.opengl.pitch;
+	return 1;
+}
+
+void ogEndUpdate( const Bit16u *changedLines )
+{	// Clear drawing area. Some drivers (on Linux) have more than 2 buffers and the screen might
+	// be dirty because of other programs.
+	glClearColor (0.0, 0.0, 0.0, 1.0);
+	glClear(GL_COLOR_BUFFER_BIT);
+	if (sdl.opengl.pixel_buffer_object) {
+		glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT);
+		glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
+		glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0,
+				sdl.draw.width, sdl.draw.height, GL_BGRA_EXT,
+				GL_UNSIGNED_INT_8_8_8_8_REV, 0);
+		glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
+		glCallList(sdl.opengl.displaylist);
+		SDL_GL_SwapBuffers();
+	} else if (changedLines) {
+		Bitu y = 0, index = 0;
+		glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
+		while (y < sdl.draw.height) {
+			if (!(index & 1)) {
+				y += changedLines[index];
+			} else {
+				Bit8u *pixels = (Bit8u *)sdl.opengl.framebuf + y * sdl.opengl.pitch;
+				Bitu height = changedLines[index];
+				glTexSubImage2D(GL_TEXTURE_2D, 0, 0, y,
+					sdl.draw.width, height, GL_BGRA_EXT,
+					GL_UNSIGNED_INT_8_8_8_8_REV, pixels );
+				y += height;
+			}
+			index++;
+		}
+		glCallList(sdl.opengl.displaylist);
+		SDL_GL_SwapBuffers();
+	}
+}
+
+Bitu ogGetRgb( Bit8u red, Bit8u green, Bit8u blue )
+{	return ((blue << 0) | (green << 8) | (red << 16)) | (255 << 24);  }
+
+Bitu ssdBestMode( Bitu *flags )
+{	Bitu testbpp;
+	if (!(*flags&(GFX_CAN_15|GFX_CAN_16|GFX_CAN_32)))
+	{	testbpp = CheckSurface( &*flags );  }
+	else
+	{	if (*flags & GFX_LOVE_15)
+		{	testbpp=15;  }
+		else if (*flags & GFX_LOVE_16) testbpp=16;
+		else if (*flags & GFX_LOVE_32) testbpp=32;
+		else testbpp=0;
+		*flags|=GFX_SCALING;
+	}
+	return testbpp;
+}
+
 #if C_DDRAW
-	case SCREEN_SURFACE_DDRAW:
-		if (!(flags&(GFX_CAN_15|GFX_CAN_16|GFX_CAN_32))) goto check_surface;
-		if (flags & GFX_LOVE_15) testbpp=15;
-		else if (flags & GFX_LOVE_16) testbpp=16;
-		else if (flags & GFX_LOVE_32) testbpp=32;
-		else testbpp=0;
-		flags|=GFX_SCALING;
-		goto check_gotbpp;
-#endif
-	case SCREEN_OVERLAY:
-		//We only accept 32bit output from the scalers here
-		//Can't handle true color inputs
-		if (flags & GFX_RGBONLY || !(flags&GFX_CAN_32)) goto check_surface;
-		flags|=GFX_SCALING;
-		flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
+char ssdSetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley, Bitu *retFlags){
+	int bpp = 0;
+	if (flags & GFX_CAN_15) bpp=15;
+	if (flags & GFX_CAN_16) bpp=16;
+	if (flags & GFX_CAN_32) bpp=32;
+	if (!GFX_SetupSurfaceScaled(flags, 0,bpp))
+	{	return 0;  }
+	sdl.blit.rect.top=sdl.clip.y;
+	sdl.blit.rect.left=sdl.clip.x;
+	sdl.blit.rect.right=sdl.clip.x+sdl.clip.w;
+	sdl.blit.rect.bottom=sdl.clip.y+sdl.clip.h;
+	sdl.blit.surface=SDL_CreateRGBSurface(SDL_HWSURFACE,sdl.draw.width,sdl.draw.height,
+			sdl.surface->format->BitsPerPixel,
+			sdl.surface->format->Rmask,
+			sdl.surface->format->Gmask,
+			sdl.surface->format->Bmask,
+			0);
+	if (!sdl.blit.surface || (!sdl.blit.surface->flags&SDL_HWSURFACE)) {
+		if (sdl.blit.surface) {
+			SDL_FreeSurface(sdl.blit.surface);
+			sdl.blit.surface=0;
+		}
+		LOG_MSG("Failed to create ddraw surface, back to normal surface.");
+		return 0; // Error
+	}
+	switch (sdl.surface->format->BitsPerPixel) {
+	case 15:
+		*retFlags = GFX_CAN_15 | GFX_SCALING | GFX_HARDWARE;
 		break;
-#if C_OPENGL
-	case SCREEN_OPENGL:
-		//We only accept 32bit output from the scalers here
-		if (!(flags&GFX_CAN_32)) goto check_surface;
-		flags|=GFX_SCALING;
-		flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
+	case 16:
+		*retFlags = GFX_CAN_16 | GFX_SCALING | GFX_HARDWARE;
+				break;
+	case 32:
+		*retFlags = GFX_CAN_32 | GFX_SCALING | GFX_HARDWARE;
+				break;
+	}
+	return 1; // Success;
+}
+
+char ssdStartUpdate( Bit8u **pixels, Bitu *pitch )
+{	if (SDL_LockSurface(sdl.blit.surface)) {
+//			LOG_MSG("SDL Lock failed");
+		return 0;
+	}
+	*pixels=(Bit8u *)sdl.blit.surface->pixels;
+	*pitch=sdl.blit.surface->pitch;
+	return 1;
+}
+
+void ssdEndUpdate( const Bit16u *changedLines )
+{	int ret;
+	SDL_UnlockSurface(sdl.blit.surface);
+	ret=IDirectDrawSurface3_Blt(
+		sdl.surface->hwdata->dd_writebuf,&sdl.blit.rect,
+		sdl.blit.surface->hwdata->dd_surface,0,
+		DDBLT_WAIT, NULL);
+	switch (ret) {
+	case DD_OK:
 		break;
-#endif
+	case DDERR_SURFACELOST:
+		IDirectDrawSurface3_Restore(sdl.blit.surface->hwdata->dd_surface);
+		IDirectDrawSurface3_Restore(sdl.surface->hwdata->dd_surface);
+		break;
 	default:
-		goto check_surface;
-		break;
+		LOG_MSG("DDRAW:Failed to blit, error %X",ret);
 	}
+	SDL_Flip(sdl.surface);
+}
+
+Bitu ssdGetRgb( Bit8u red, Bit8u green, Bit8u blue )
+{	return SDL_MapRGB(sdl.surface->format,red,green,blue);  }
+#endif
+
+ScreenTypeInfo info[10];
+void AddScreenType( SCREEN_TYPES type, FGetBestMode bm, FSetSize ss, FStartUpdate su, FEndUpdate eu, FGetRgb gr )
+{	PScreenTypeInfo st = &info[type];
+	st->GetBestMode = bm;
+	st->SetSize     = ss;
+	st->StartUpdate = su;
+	st->EndUpdate   = eu;
+	st->GetRgb      = gr;
+}
+
+void InitScreenTypes()
+{	AddScreenType( SCREEN_SURFACE,        &ssBestMode,  &ssSetSize,  &ssStartUpdate, &ssEndUpdate, &ssGetRgb );
+	AddScreenType( SCREEN_OVERLAY,        &soBestMode,  &soSetSize,  &soStartUpdate, &soEndUpdate, &soGetRgb );
+	AddScreenType( SCREEN_OPENGL,         &ogBestMode,  &ogSetSize,  &ogStartUpdate, &ogEndUpdate, &ogGetRgb );
+#if C_DDRAW
+	AddScreenType( SCREEN_SURFACE_DDRAW,  &ssdBestMode, &ssdSetSize, &ssdStartUpdate, &ssdEndUpdate,&ssdGetRgb );
+#endif
+}
+
+char stInited = 0;
+PScreenTypeInfo GetScreenTypeInfo( SCREEN_TYPES type )
+{	if( !stInited )
+	{	stInited = 1;
+		InitScreenTypes();
+	}
+	// This precaution is redundant because the availability of DDRAW is tested
+	// at compile time, and that too is redundant (repeated use of #if C_DDRAW
+	if( info[ type ].GetBestMode == NULL)	{	type = SCREEN_SURFACE;  }
+	return &(info[ type ]);
+}
+
+/* Reset the screen with current values in the sdl structure */
+Bitu GFX_GetBestMode(Bitu flags) {
+	int testbpp = GetScreenTypeInfo( sdl.desktop.want_type)->GetBestMode(&flags);
+	if( testbpp )
+	{	CheckGotBpp( &flags, testbpp );  }
 	return flags;
 }
 
@@ -455,27 +1327,20 @@
 	}
 }
 
-static int int_log2 (int val) {
-    int log = 0;
-    while ((val >>= 1) != 0)
-	log++;
-    return log;
-}
 
-
-static SDL_Surface * GFX_SetupSurfaceScaled(Bit32u sdl_flags, Bit32u bpp) {
+static SDL_Surface * GFX_SetupSurfaceScaled(Bitu flags, Bit32u sdl_flags, Bit32u bpp) {
 	Bit16u fixedWidth;
 	Bit16u fixedHeight;
 
+	sdl_flags |= genflags(flags);
 	if (sdl.desktop.fullscreen) {
 		fixedWidth = sdl.desktop.full.fixed ? sdl.desktop.full.width : 0;
 		fixedHeight = sdl.desktop.full.fixed ? sdl.desktop.full.height : 0;
-		sdl_flags |= SDL_FULLSCREEN|SDL_HWSURFACE;
 	} else {
 		fixedWidth = sdl.desktop.window.width;
 		fixedHeight = sdl.desktop.window.height;
-		sdl_flags |= SDL_HWSURFACE;
 	}
+
 	if (fixedWidth && fixedHeight) {
 		double ratio_w=(double)fixedWidth/(sdl.draw.width*sdl.draw.scalex);
 		double ratio_h=(double)fixedHeight/(sdl.draw.height*sdl.draw.scaley);
@@ -501,14 +1366,13 @@
 			sdl.clip.x = 0;
 			sdl.clip.y = 0;
 		}
-		return sdl.surface;
 	} else {
 		sdl.clip.x=0;sdl.clip.y=0;
 		sdl.clip.w=(Bit16u)(sdl.draw.width*sdl.draw.scalex);
 		sdl.clip.h=(Bit16u)(sdl.draw.height*sdl.draw.scaley);
 		sdl.surface=SDL_SetVideoMode_Wrap(sdl.clip.w,sdl.clip.h,bpp,sdl_flags);
-		return sdl.surface;
 	}
+	return sdl.surface;
 }
 
 void GFX_TearDown(void) {
@@ -521,16 +1385,20 @@
 	}
 }
 
-Bitu GFX_SetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley,GFX_CallBack_t callback) {
+Bitu GFX_SetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley,GFX_CallBack_t callback, double aspect ) {
 	if (sdl.updating)
 		GFX_EndUpdate( 0 );
 
 	sdl.draw.width=width;
 	sdl.draw.height=height;
+	sdl.draw.aspect=aspect;
 	sdl.draw.callback=callback;
 	sdl.draw.scalex=scalex;
 	sdl.draw.scaley=scaley;
 
+	sdl.dbl_h = ( flags & GFX_DBL_H ) > 0;
+	sdl.dbl_w = ( flags & GFX_DBL_W ) > 0;
+
 	int bpp=0;
 	Bitu retFlags = 0;
 
@@ -538,243 +1406,15 @@
 		SDL_FreeSurface(sdl.blit.surface);
 		sdl.blit.surface=0;
 	}
-	switch (sdl.desktop.want_type) {
-	case SCREEN_SURFACE:
-dosurface:
-		if (flags & GFX_CAN_8) bpp=8;
-		if (flags & GFX_CAN_15) bpp=15;
-		if (flags & GFX_CAN_16) bpp=16;
-		if (flags & GFX_CAN_32) bpp=32;
-		sdl.desktop.type=SCREEN_SURFACE;
-		sdl.clip.w=width;
-		sdl.clip.h=height;
-		if (sdl.desktop.fullscreen) {
-			if (sdl.desktop.full.fixed) {
-				sdl.clip.x=(Sint16)((sdl.desktop.full.width-width)/2);
-				sdl.clip.y=(Sint16)((sdl.desktop.full.height-height)/2);
-				sdl.surface=SDL_SetVideoMode_Wrap(sdl.desktop.full.width,sdl.desktop.full.height,bpp,
-					SDL_FULLSCREEN | ((flags & GFX_CAN_RANDOM) ? SDL_SWSURFACE : SDL_HWSURFACE) |
-					(sdl.desktop.doublebuf ? SDL_DOUBLEBUF|SDL_ASYNCBLIT : 0) | SDL_HWPALETTE);
-				if (sdl.surface == NULL) E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",sdl.desktop.full.width,sdl.desktop.full.height,bpp,SDL_GetError());
-			} else {
-				sdl.clip.x=0;sdl.clip.y=0;
-				sdl.surface=SDL_SetVideoMode_Wrap(width,height,bpp,
-					SDL_FULLSCREEN | ((flags & GFX_CAN_RANDOM) ? SDL_SWSURFACE : SDL_HWSURFACE) |
-					(sdl.desktop.doublebuf ? SDL_DOUBLEBUF|SDL_ASYNCBLIT  : 0)|SDL_HWPALETTE);
-				if (sdl.surface == NULL)
-					E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",(int)width,(int)height,bpp,SDL_GetError());
-			}
-		} else {
-			sdl.clip.x=0;sdl.clip.y=0;
-			sdl.surface=SDL_SetVideoMode_Wrap(width,height,bpp,(flags & GFX_CAN_RANDOM) ? SDL_SWSURFACE : SDL_HWSURFACE);
-#ifdef WIN32
-			if (sdl.surface == NULL) {
-				SDL_QuitSubSystem(SDL_INIT_VIDEO);
-				if (!sdl.using_windib) {
-					LOG_MSG("Failed to create hardware surface.\nRestarting video subsystem with windib enabled.");
-					putenv("SDL_VIDEODRIVER=windib");
-					sdl.using_windib=true;
-				} else {
-					LOG_MSG("Failed to create hardware surface.\nRestarting video subsystem with directx enabled.");
-					putenv("SDL_VIDEODRIVER=directx");
-					sdl.using_windib=false;
-				}
-				SDL_InitSubSystem(SDL_INIT_VIDEO);
-				GFX_SetIcon(); //Set Icon again
-				sdl.surface = SDL_SetVideoMode_Wrap(width,height,bpp,SDL_HWSURFACE);
-				if(sdl.surface) GFX_SetTitle(-1,-1,false); //refresh title.
-			}
-#endif
-			if (sdl.surface == NULL)
-				E_Exit("Could not set windowed video mode %ix%i-%i: %s",(int)width,(int)height,bpp,SDL_GetError());
-		}
-		if (sdl.surface) {
-			switch (sdl.surface->format->BitsPerPixel) {
-			case 8:
-				retFlags = GFX_CAN_8;
-                break;
-			case 15:
-				retFlags = GFX_CAN_15;
-				break;
-			case 16:
-				retFlags = GFX_CAN_16;
-                break;
-			case 32:
-				retFlags = GFX_CAN_32;
-                break;
-			}
-			if (retFlags && (sdl.surface->flags & SDL_HWSURFACE))
-				retFlags |= GFX_HARDWARE;
-			if (retFlags && (sdl.surface->flags & SDL_DOUBLEBUF)) {
-				sdl.blit.surface=SDL_CreateRGBSurface(SDL_HWSURFACE,
-					sdl.draw.width, sdl.draw.height,
-					sdl.surface->format->BitsPerPixel,
-					sdl.surface->format->Rmask,
-					sdl.surface->format->Gmask,
-					sdl.surface->format->Bmask,
-				0);
-				/* If this one fails be ready for some flickering... */
-			}
-		}
-		break;
-#if C_DDRAW
-	case SCREEN_SURFACE_DDRAW:
-		if (flags & GFX_CAN_15) bpp=15;
-		if (flags & GFX_CAN_16) bpp=16;
-		if (flags & GFX_CAN_32) bpp=32;
-		if (!GFX_SetupSurfaceScaled((sdl.desktop.doublebuf && sdl.desktop.fullscreen) ? SDL_DOUBLEBUF : 0,bpp)) goto dosurface;
-		sdl.blit.rect.top=sdl.clip.y;
-		sdl.blit.rect.left=sdl.clip.x;
-		sdl.blit.rect.right=sdl.clip.x+sdl.clip.w;
-		sdl.blit.rect.bottom=sdl.clip.y+sdl.clip.h;
-		sdl.blit.surface=SDL_CreateRGBSurface(SDL_HWSURFACE,sdl.draw.width,sdl.draw.height,
-				sdl.surface->format->BitsPerPixel,
-				sdl.surface->format->Rmask,
-				sdl.surface->format->Gmask,
-				sdl.surface->format->Bmask,
-				0);
-		if (!sdl.blit.surface || (!sdl.blit.surface->flags&SDL_HWSURFACE)) {
-			if (sdl.blit.surface) {
-				SDL_FreeSurface(sdl.blit.surface);
-				sdl.blit.surface=0;
-			}
-			LOG_MSG("Failed to create ddraw surface, back to normal surface.");
-			goto dosurface;
-		}
-		switch (sdl.surface->format->BitsPerPixel) {
-		case 15:
-			retFlags = GFX_CAN_15 | GFX_SCALING | GFX_HARDWARE;
-			break;
-		case 16:
-			retFlags = GFX_CAN_16 | GFX_SCALING | GFX_HARDWARE;
-               break;
-		case 32:
-			retFlags = GFX_CAN_32 | GFX_SCALING | GFX_HARDWARE;
-               break;
-		}
-		sdl.desktop.type=SCREEN_SURFACE_DDRAW;
-		break;
-#endif
-	case SCREEN_OVERLAY:
-		if (sdl.overlay) {
-			SDL_FreeYUVOverlay(sdl.overlay);
-			sdl.overlay=0;
-		}
-		if (!(flags&GFX_CAN_32) || (flags & GFX_RGBONLY)) goto dosurface;
-		if (!GFX_SetupSurfaceScaled(0,0)) goto dosurface;
-		sdl.overlay=SDL_CreateYUVOverlay(width*2,height,SDL_UYVY_OVERLAY,sdl.surface);
-		if (!sdl.overlay) {
-			LOG_MSG("SDL: Failed to create overlay, switching back to surface");
-			goto dosurface;
-		}
-		sdl.desktop.type=SCREEN_OVERLAY;
-		retFlags = GFX_CAN_32 | GFX_SCALING | GFX_HARDWARE;
-		break;
-#if C_OPENGL
-	case SCREEN_OPENGL:
-	{
-		if (sdl.opengl.pixel_buffer_object) {
-			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
-			if (sdl.opengl.buffer) glDeleteBuffersARB(1, &sdl.opengl.buffer);
-		} else if (sdl.opengl.framebuf) {
-			free(sdl.opengl.framebuf);
-		}
-		sdl.opengl.framebuf=0;
-		if (!(flags&GFX_CAN_32)) goto dosurface;
-		int texsize=2 << int_log2(width > height ? width : height);
-		if (texsize>sdl.opengl.max_texsize) {
-			LOG_MSG("SDL:OPENGL: No support for texturesize of %d, falling back to surface",texsize);
-			goto dosurface;
-		}
-		SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
-#if SDL_VERSION_ATLEAST(1, 2, 11)
-		SDL_GL_SetAttribute( SDL_GL_SWAP_CONTROL, 0 );
-#endif
-		GFX_SetupSurfaceScaled(SDL_OPENGL,0);
-		if (!sdl.surface || sdl.surface->format->BitsPerPixel<15) {
-			LOG_MSG("SDL:OPENGL: Can't open drawing surface, are you running in 16bpp (or higher) mode?");
-			goto dosurface;
-		}
-		/* Create the texture and display list */
-		if (sdl.opengl.pixel_buffer_object) {
-			glGenBuffersARB(1, &sdl.opengl.buffer);
-			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, sdl.opengl.buffer);
-			glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_EXT, width*height*4, NULL, GL_STREAM_DRAW_ARB);
-			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
-		} else {
-			sdl.opengl.framebuf=malloc(width*height*4);		//32 bit color
-		}
-		sdl.opengl.pitch=width*4;
 
-		if(sdl.clip.x ==0 && sdl.clip.y ==0 && sdl.desktop.fullscreen && !sdl.desktop.full.fixed && (sdl.clip.w != sdl.surface->w || sdl.clip.h != sdl.surface->h)) { 
-//			LOG_MSG("attempting to fix the centering to %d %d %d %d",(sdl.surface->w-sdl.clip.w)/2,(sdl.surface->h-sdl.clip.h)/2,sdl.clip.w,sdl.clip.h);
-			glViewport((sdl.surface->w-sdl.clip.w)/2,(sdl.surface->h-sdl.clip.h)/2,sdl.clip.w,sdl.clip.h);
-		} else {
-			glViewport(sdl.clip.x,sdl.clip.y,sdl.clip.w,sdl.clip.h);
-		}		
-
-		glMatrixMode (GL_PROJECTION);
-		glDeleteTextures(1,&sdl.opengl.texture);
- 		glGenTextures(1,&sdl.opengl.texture);
-		glBindTexture(GL_TEXTURE_2D,sdl.opengl.texture);
-		// No borders
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-		if (!sdl.opengl.bilinear || ( (sdl.clip.h % height) == 0 && (sdl.clip.w % width) == 0) ) {
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-		} else {
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-		}
-
-		Bit8u* emptytex = new Bit8u[texsize * texsize * 4];
-		memset((void*) emptytex, 0, texsize * texsize * 4);
-		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, texsize, texsize, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, (const GLvoid*)emptytex);
-		delete [] emptytex;
-
-		glClearColor (0.0, 0.0, 0.0, 1.0);
-		glClear(GL_COLOR_BUFFER_BIT);
-		SDL_GL_SwapBuffers();
-		glClear(GL_COLOR_BUFFER_BIT);
-		glShadeModel (GL_FLAT);
-		glDisable (GL_DEPTH_TEST);
-		glDisable (GL_LIGHTING);
-		glDisable(GL_CULL_FACE);
-		glEnable(GL_TEXTURE_2D);
-		glMatrixMode (GL_MODELVIEW);
-		glLoadIdentity ();
-
-		GLfloat tex_width=((GLfloat)(width)/(GLfloat)texsize);
-		GLfloat tex_height=((GLfloat)(height)/(GLfloat)texsize);
-
-		if (glIsList(sdl.opengl.displaylist)) glDeleteLists(sdl.opengl.displaylist, 1);
-		sdl.opengl.displaylist = glGenLists(1);
-		glNewList(sdl.opengl.displaylist, GL_COMPILE);
-		glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
-		glBegin(GL_QUADS);
-		// lower left
-		glTexCoord2f(0,tex_height); glVertex2f(-1.0f,-1.0f);
-		// lower right
-		glTexCoord2f(tex_width,tex_height); glVertex2f(1.0f, -1.0f);
-		// upper right
-		glTexCoord2f(tex_width,0); glVertex2f(1.0f, 1.0f);
-		// upper left
-		glTexCoord2f(0,0); glVertex2f(-1.0f, 1.0f);
-		glEnd();
-		glEndList();
-		sdl.desktop.type=SCREEN_OPENGL;
-		retFlags = GFX_CAN_32 | GFX_SCALING;
-		if (sdl.opengl.pixel_buffer_object)
-			retFlags |= GFX_HARDWARE;
-	break;
-		}//OPENGL
-#endif	//C_OPENGL
-	default:
-		goto dosurface;
-		break;
-	}//CASE
-	if (retFlags)
+	ScreenTypeInfo* screen;
+	screen = GetScreenTypeInfo( sdl.desktop.want_type );
+	if( screen->SetSize(width, height, flags, scalex, scaley, &retFlags) )
+	{	goto success;  }
+	screen  = GetScreenTypeInfo( SCREEN_SURFACE ); // Backup
+	screen->SetSize(width, height, flags, scalex, scaley, &retFlags);
+success:
+	sdl.desktop.screen = *screen;	if (retFlags)
 		GFX_Start();
 	if (!sdl.mouse.autoenable) SDL_ShowCursor(sdl.mouse.autolock?SDL_DISABLE:SDL_ENABLE);
 	return retFlags;
@@ -876,7 +1516,7 @@
 }
 
 void GFX_RestoreMode(void) {
-	GFX_SetSize(sdl.draw.width,sdl.draw.height,sdl.draw.flags,sdl.draw.scalex,sdl.draw.scaley,sdl.draw.callback);
+	GFX_SetSize(sdl.draw.width,sdl.draw.height,sdl.draw.flags,sdl.draw.scalex,sdl.draw.scaley,sdl.draw.callback, sdl.draw.aspect); //TODO: Is passing sdl.aspect correct here?
 	GFX_UpdateSDLCaptureState();
 }
 
@@ -883,167 +1523,21 @@
 
 bool GFX_StartUpdate(Bit8u * & pixels,Bitu & pitch) {
 	if (!sdl.active || sdl.updating)
-		return false;
-	switch (sdl.desktop.type) {
-	case SCREEN_SURFACE:
-		if (sdl.blit.surface) {
-			if (SDL_MUSTLOCK(sdl.blit.surface) && SDL_LockSurface(sdl.blit.surface))
-				return false;
-			pixels=(Bit8u *)sdl.blit.surface->pixels;
-			pitch=sdl.blit.surface->pitch;
-		} else {
-			if (SDL_MUSTLOCK(sdl.surface) && SDL_LockSurface(sdl.surface))
-				return false;
-			pixels=(Bit8u *)sdl.surface->pixels;
-			pixels+=sdl.clip.y*sdl.surface->pitch;
-			pixels+=sdl.clip.x*sdl.surface->format->BytesPerPixel;
-			pitch=sdl.surface->pitch;
-		}
-		sdl.updating=true;
-		return true;
-#if C_DDRAW
-	case SCREEN_SURFACE_DDRAW:
-		if (SDL_LockSurface(sdl.blit.surface)) {
-//			LOG_MSG("SDL Lock failed");
-			return false;
-		}
-		pixels=(Bit8u *)sdl.blit.surface->pixels;
-		pitch=sdl.blit.surface->pitch;
-		sdl.updating=true;
-		return true;
-#endif
-	case SCREEN_OVERLAY:
-		if (SDL_LockYUVOverlay(sdl.overlay)) return false;
-		pixels=(Bit8u *)*(sdl.overlay->pixels);
-		pitch=*(sdl.overlay->pitches);
-		sdl.updating=true;
-		return true;
-#if C_OPENGL
-	case SCREEN_OPENGL:
-		if(sdl.opengl.pixel_buffer_object) {
-		    glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, sdl.opengl.buffer);
-		    pixels=(Bit8u *)glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, GL_WRITE_ONLY);
-		} else
-		    pixels=(Bit8u *)sdl.opengl.framebuf;
-		pitch=sdl.opengl.pitch;
-		sdl.updating=true;
-		return true;
-#endif
-	default:
-		break;
-	}
-	return false;
+	{	return false;  }
+	if( !sdl.desktop.screen.StartUpdate( &pixels, &pitch ) )
+	{	return false;  }
+	sdl.updating = true;
+	return true;
 }
 
 
 void GFX_EndUpdate( const Bit16u *changedLines ) {
-#if C_DDRAW
-	int ret;
-#endif
 	if (!sdl.updating)
 		return;
 	sdl.updating=false;
-	switch (sdl.desktop.type) {
-	case SCREEN_SURFACE:
-		if (SDL_MUSTLOCK(sdl.surface)) {
-			if (sdl.blit.surface) {
-				SDL_UnlockSurface(sdl.blit.surface);
-				int Blit = SDL_BlitSurface( sdl.blit.surface, 0, sdl.surface, &sdl.clip );
-				LOG(LOG_MISC,LOG_WARN)("BlitSurface returned %d",Blit);
-			} else {
-				SDL_UnlockSurface(sdl.surface);
-			}
-			SDL_Flip(sdl.surface);
-		} else if (changedLines) {
-			Bitu y = 0, index = 0, rectCount = 0;
-			while (y < sdl.draw.height) {
-				if (!(index & 1)) {
-					y += changedLines[index];
-				} else {
-					SDL_Rect *rect = &sdl.updateRects[rectCount++];
-					rect->x = sdl.clip.x;
-					rect->y = sdl.clip.y + y;
-					rect->w = (Bit16u)sdl.draw.width;
-					rect->h = changedLines[index];
-#if 0
-					if (rect->h + rect->y > sdl.surface->h) {
-						LOG_MSG("WTF %d +  %d  >%d",rect->h,rect->y,sdl.surface->h);
-					}
-#endif
-					y += changedLines[index];
-				}
-				index++;
-			}
-			if (rectCount)
-				SDL_UpdateRects( sdl.surface, rectCount, sdl.updateRects );
-		}
-		break;
-#if C_DDRAW
-	case SCREEN_SURFACE_DDRAW:
-		SDL_UnlockSurface(sdl.blit.surface);
-		ret=IDirectDrawSurface3_Blt(
-			sdl.surface->hwdata->dd_writebuf,&sdl.blit.rect,
-			sdl.blit.surface->hwdata->dd_surface,0,
-			DDBLT_WAIT, NULL);
-		switch (ret) {
-		case DD_OK:
-			break;
-		case DDERR_SURFACELOST:
-			IDirectDrawSurface3_Restore(sdl.blit.surface->hwdata->dd_surface);
-			IDirectDrawSurface3_Restore(sdl.surface->hwdata->dd_surface);
-			break;
-		default:
-			LOG_MSG("DDRAW: Failed to blit, error %X",ret);
-		}
-		SDL_Flip(sdl.surface);
-		break;
-#endif
-	case SCREEN_OVERLAY:
-		SDL_UnlockYUVOverlay(sdl.overlay);
-		SDL_DisplayYUVOverlay(sdl.overlay,&sdl.clip);
-		break;
-#if C_OPENGL
-	case SCREEN_OPENGL:
-		// Clear drawing area. Some drivers (on Linux) have more than 2 buffers and the screen might
-		// be dirty because of other programs.
-		glClearColor (0.0, 0.0, 0.0, 1.0);
-		glClear(GL_COLOR_BUFFER_BIT);
-		if (sdl.opengl.pixel_buffer_object) {
-			glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT);
-			glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
-			glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0,
-					sdl.draw.width, sdl.draw.height, GL_BGRA_EXT,
-					GL_UNSIGNED_INT_8_8_8_8_REV, 0);
-			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
-			glCallList(sdl.opengl.displaylist);
-			SDL_GL_SwapBuffers();
-		} else if (changedLines) {
-			Bitu y = 0, index = 0;
-			glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
-			while (y < sdl.draw.height) {
-				if (!(index & 1)) {
-					y += changedLines[index];
-				} else {
-					Bit8u *pixels = (Bit8u *)sdl.opengl.framebuf + y * sdl.opengl.pitch;
-					Bitu height = changedLines[index];
-					glTexSubImage2D(GL_TEXTURE_2D, 0, 0, y,
-						sdl.draw.width, height, GL_BGRA_EXT,
-						GL_UNSIGNED_INT_8_8_8_8_REV, pixels );
-					y += height;
-				}
-				index++;
-			}
-			glCallList(sdl.opengl.displaylist);
-			SDL_GL_SwapBuffers();
-		}
-		break;
-#endif
-	default:
-		break;
-	}
+	sdl.desktop.screen.EndUpdate( changedLines );
 }
 
-
 void GFX_SetPalette(Bitu start,Bitu count,GFX_PalEntry * entries) {
 	/* I should probably not change the GFX_PalEntry :) */
 	if (sdl.surface->flags & SDL_HWPALETTE) {
@@ -1176,6 +1649,34 @@
 //extern void UI_Run(bool);
 void Restart(bool pressed);
 
+enum ResKind { RES_ORIGINAL, RES_DESKTOP, RES_FIXED };
+
+ResKind ParseRes( char* res, Bit16u* w, Bit16u* h )
+{	char* height = NULL;
+	*w = 0; *h = 0;
+	ResKind kind = RES_ORIGINAL;
+	if( res == NULL || *res == '\0' )
+	{	goto end;  }
+	char res_buf[100];
+	safe_strncpy( res_buf, res, sizeof( res_buf ) );
+	res = lowcase ( res_buf );//so x and X are allowed
+	if( strcmp( res,"original" ) == 0 )
+	{	goto end;  }
+	if( strcmp( res,"desktop" ) == 0 )
+	{	kind = RES_DESKTOP;
+		goto end;
+	}
+	height = const_cast<char*>(strchr(res,'x'));
+	if( height == NULL || *height == '\0' )
+	{	goto end;  }
+	kind    = RES_FIXED;
+	*height = 0;
+	*h   = ( Bit16u )atoi( height + 1 );
+	*w   = ( Bit16u )atoi( res );
+end:
+	return kind;
+}
+
 static void GUI_StartUp(Section * sec) {
 	sec->AddDestroyFunction(&GUI_ShutDown);
 	Section_prop * section=static_cast<Section_prop *>(sec);
@@ -1188,6 +1689,7 @@
 	sdl.desktop.lazy_fullscreen_req=false;
 
 	sdl.desktop.fullscreen=section->Get_bool("fullscreen");
+	sdl.desktop.fullborderless=section->Get_bool("fullborderless");
 	sdl.wait_on_error=section->Get_bool("waitonerror");
 
 	Prop_multival* p=section->Get_multival("priority");
@@ -1308,6 +1790,20 @@
 
 	if (output == "surface") {
 		sdl.desktop.want_type=SCREEN_SURFACE;
+	} else if (output == "surfacepp") {
+		sdl.desktop.want_type=SCREEN_SURFACE;
+		sdl.SurfaceMode = SM_PERFECT;
+	} else if (output == "surfacenp") {
+		sdl.ps_sharpness=(double)section->Get_int("surfacenp-sharpness") / 100.0;
+		sdl.desktop.want_type=SCREEN_SURFACE;
+		// fallback to nearest-neighbor for better performace:
+		if( sdl.ps_sharpness == 1.0 ) 
+		{	sdl.SurfaceMode = SM_NEIGHBOR;  }
+		else
+		{	sdl.SurfaceMode = SM_SOFT;  }
+	} else if (output == "surfacenb") {
+		sdl.desktop.want_type=SCREEN_SURFACE;
+		sdl.SurfaceMode = SM_NEIGHBOR;
 #if C_DDRAW
 	} else if (output == "ddraw") {
 		sdl.desktop.want_type=SCREEN_SURFACE_DDRAW;
@@ -1317,10 +1813,13 @@
 #if C_OPENGL
 	} else if (output == "opengl") {
 		sdl.desktop.want_type=SCREEN_OPENGL;
-		sdl.opengl.bilinear=true;
+		sdl.opengl.kind = GlkBilinear;
 	} else if (output == "openglnb") {
 		sdl.desktop.want_type=SCREEN_OPENGL;
-		sdl.opengl.bilinear=false;
+		sdl.opengl.kind = GlkNearest;
+	} else if (output == "openglpp") {
+		sdl.desktop.want_type=SCREEN_OPENGL;
+		sdl.opengl.kind = GlkPerfect;
 #endif
 	} else {
 		LOG_MSG("SDL: Unsupported output device %s, switching back to surface",output.c_str());
@@ -1736,10 +2236,13 @@
 	Pbool = sdl_sec->Add_bool("fullscreen",Property::Changeable::Always,false);
 	Pbool->Set_help("Start dosbox directly in fullscreen. (Press ALT-Enter to go back)");
 
+	Pbool = sdl_sec->Add_bool("fullborderless",Property::Changeable::Always,false);
+	Pbool->Set_help("Emulate fullscreen as a borderless window");
+
 	Pbool = sdl_sec->Add_bool("fulldouble",Property::Changeable::Always,false);
 	Pbool->Set_help("Use double buffering in fullscreen. It can reduce screen flickering, but it can also result in a slow DOSBox.");
 
-	Pstring = sdl_sec->Add_string("fullresolution",Property::Changeable::Always,"original");
+	Pstring = sdl_sec->Add_string("fullresolution",Property::Changeable::Always,"desktop");
 	Pstring->Set_help("What resolution to use for fullscreen: original, desktop or a fixed size (e.g. 1024x768).\n"
 	                  "Using your monitor's native resolution with aspect=true might give the best results.\n"
 			  "If you end up with small window on a large screen, try an output different from surface."
@@ -1746,22 +2249,47 @@
 	                  "On Windows 10 with display scaling (Scale and layout) set to a value above 100%, it is recommended\n"
 	                  "to use a lower full/windowresolution, in order to avoid window size problems.");
 
-	Pstring = sdl_sec->Add_string("windowresolution",Property::Changeable::Always,"original");
+	Pstring = sdl_sec->Add_string("windowresolution",Property::Changeable::Always,"desktop");
 	Pstring->Set_help("Scale the window to this size IF the output device supports hardware scaling.\n"
 	                  "(output=surface does not!)");
 
 	const char* outputs[] = {
-		"surface", "overlay",
+		"surface", "surfacepp", "surfacenp", "surfacenb", "overlay",
 #if C_OPENGL
-		"opengl", "openglnb",
+		"opengl", "openglnb", "openglpp",
 #endif
 #if C_DDRAW
 		"ddraw",
 #endif
-		0 };
-	Pstring = sdl_sec->Add_string("output",Property::Changeable::Always,"surface");
-	Pstring->Set_help("What video system to use for output.");
+		0
+	};
+	Pstring = sdl_sec->Add_string("output",Property::Changeable::Always,
+#if C_OPENGL
+	"openglpp"
+#else
+	"surfacepp"
+#endif
+	);
+	Pstring->Set_help
+	(	"What video system to use for output.\n"
+		"Some values are aliases for output-scaler combinations:\n"
+		"  surfacepp and openglpp -- pixel-perfect scaling;\n"
+		"  surfacenp -- near-perfect scaling via bilinear interpolation;\n"
+		"  surfacenb and openglnb -- nearest-neighbor scaling."
+	);
+	Pint = sdl_sec->Add_int("surfacenp-sharpness",Property::Changeable::Always,50);
+	Pint->SetMinMax(0, 100);
+	Pint->Set_help
+	(	"Sharpness for the 'surfacenp' output type,\n"
+		"Measured in percent."
+	);
+
 	Pstring->Set_values(outputs);
+	
+#if C_OPENGL
+	Pbool = sdl_sec->Add_bool("glfullvsync",Property::Changeable::Always,false);
+	Pbool->Set_help("Activate V-Sync for OpenGL in fullscreen.");
+#endif
 
 	Pbool = sdl_sec->Add_bool("autolock",Property::Changeable::Always,true);
 	Pbool->Set_help("Mouse will automatically lock, if you click on the screen. (Press CTRL-F10 to unlock)");
